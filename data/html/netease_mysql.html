<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1519649868">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>网易技术部的MySQL中文资料</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1519649868">
    <link rel="stylesheet" href="../../css/reset.css?v1519649868">
    <link rel="stylesheet" href="../../css/md.css?v1519649868">
    <link rel="stylesheet" href="../../css/module.css?v1519649868">
    <link rel="stylesheet" href="../../css/c.css?v1519649868">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1519649868">
    <script src="../../dep/require.js?1519649868"></script>
</head>
<body>
    <div class="md"><h1>网易技术部的MySql中文资料</h1>
<h6>2018.02.13</h6>
<h2>第一篇 开发篇</h2>
<h3>第一章 帮助的使用</h3>
<h4>1.1 按照层次看帮助</h4>
<pre><code class="language-txt" data-comment=""># 不知道帮助能够提供什么
mysql&gt; ? contents
# 看自己感兴趣的部分
mysql&gt; ? data types
# 对于列出的具体数据类型,可以进一步看详细情况
mysql&gt; ? int</code></pre>
<h4>1.2 快速查阅帮助</h4>
<pre><code class="language-txt" data-comment=""># 快速查阅某项语法时,可以使用关键字进行快速查询
mysql&gt; ? show
# 想知道create table的语法
mysql&gt; ? create table
</code></pre>
<h3>第二章 表类型(存储引擎)的选择</h3>
<h4>2.1 MySql存储引擎概述</h4>
<p>mysql的存储引擎包括:MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、
ARCHIVE、CSV、BLACKHOLE、FEDERATED等,其中InnoDB和BDB提供事务安全表,其他存储引擎
都是非事务安全表。</p>
<h4>2.2 各种存储引擎的特性</h4>
<table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>DBD</th>
<th>Memory</th>
<th>InnoDB</th>
<th>Archive</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>没有</td>
<td>没有</td>
<td>有</td>
<td>64TB</td>
<td>没有</td>
</tr>
<tr>
<td>事务安全</td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>表锁</td>
<td>页锁</td>
<td>表锁</td>
<td>行锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td></td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>低</td>
<td>N/A</td>
<td>高</td>
<td>非常低</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>低</td>
<td>中等</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>非常高</td>
</tr>
<tr>
<td>支持外键</td>
<td></td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
</tr>
</tbody>
</table>
<p>最常用的两种存储引擎:</p>
<ol>
<li>
<p>每个MyISAM在磁盘上存储成三个文件。文件名和表名相同,扩展名为.frm(存储表定义)、
.MYD(MYData,存储数据)、.MYI(MYIndex,存储索引)。数据文件和索引文件可以放置在不同
的目录,平均分布io,获得更快的速度。</p>
</li>
<li>InnoDB提供了具有提交、回滚和崩溃修复能力的事务安全。</li>
</ol>
<h4>2.3 如何选择合适的存储引擎</h4>
<ol>
<li>MyISAM: 它是Web、数据仓储和其他应用环境下最常用的存储引擎之一</li>
<li>InnoDB: 用于事务处理应用程序</li>
<li>Memory: 将所有数据存储在RAM中,在需要快速查找引用和其他类似数据的环境下,可提供鸡块的访问</li>
<li>Merge: 允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起,并作为
一个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。</li>
</ol>
<h3>第三章 选择合适的数据类型</h3>
<h4>3.1 选择数据类型的基本原则</h4>
<p>使用合适的存储引擎,根据特定的存储引擎,确定如何选择合适的数据类型。</p>
<ol>
<li>MyISAM 最好使用固定长度的数据列代替可变长度的数据列</li>
<li>Memory 目前都使用固定长度的数据行存储,因此无论使用char或varchar列都没有关系</li>
<li>InnoDB 建议使用varchar</li>
</ol>
<h4>3.2 固定长度数据列与可变长度的数据列</h4>
<p>char与varchar</p>
<p>类型相同,但是保存和检索方式不同,最大长度和是否尾部空格被保留等方面也不同</p>
<table>
<thead>
<tr>
<th>值</th>
<th>char(4)</th>
<th>存储需求</th>
<th>varchar(4)</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>''</td>
<td>'    '</td>
<td>四个字节</td>
<td>''</td>
<td>一个字节</td>
</tr>
<tr>
<td>'ab'</td>
<td>'ab  '</td>
<td>四个字节</td>
<td>'ab '</td>
<td>三个字节</td>
</tr>
<tr>
<td>'abcd'</td>
<td>'abcd'</td>
<td>四个字节</td>
<td>'abcd '</td>
<td>五个字节</td>
</tr>
<tr>
<td>'abcdefg'</td>
<td>'abcd'</td>
<td>四个字节</td>
<td>'abcd '</td>
<td>五个字节</td>
</tr>
</tbody>
</table>
<pre><code class="language-txt" data-comment="">mysql&gt; create table vc(v varchar(4), c char(4));
Query OK, 0 rows affected (0.04 sec)

mysql&gt; insert into vc values('ab ', 'ab ');
Query OK, 1 row affected (0.01 sec)

mysql&gt; select concat(v, '+'), concat(c, '+') from vc;
+----------------+----------------+
| concat(v, '+') | concat(c, '+') |
+----------------+----------------+
| ab +           | ab+            |
+----------------+----------------+
1 row in set (0.01 sec)
</code></pre>
<p>text和blob</p>
<ul>
<li>blob和text值也会引起自己的一些问题,特别是执行了大量的删除或更新操作</li>
</ul>
<p>删除会留下&quot;空洞&quot;,找出空间碎片,建议定期使用<code class="inline-code">optimize table</code>定期整理</p>
<ul>
<li>使用合成的(synthetic)索引</li>
</ul>
<p>合成的散列索引对于那些blob或text数据列特别有用。用散列标志符值查找的速度比搜索blob列本身
的速度快得多</p>
<ul>
<li>
<p>在不必要的时候避免检索大型的blob或text值</p>
</li>
<li>把blob或text列分离到单独的表中</li>
</ul>
<p>减少主表中的碎片</p>
<h4>3.3 浮点数和定点数</h4>
<pre><code class="language-txt" data-comment="">mysql&gt; create table test(c1 float(10,2),c2 decimal(10,2));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; insert into test values(131072.32, 131072.32);
Query OK, 1 row affected (0.00 sec)

mysql&gt; select * from test;
+-----------+-----------+
| c1        | c2        |
+-----------+-----------+
| 131072.31 | 131072.32 |
+-----------+-----------+
1 row in set (0.00 sec)</code></pre>
<ol>
<li>浮点数存在误差问题</li>
<li>对货币等精度敏感的数据,应该使用定点数表示或存储</li>
<li>编程中,如果用到浮点数,要特别注意误差问题,并尽量避免做浮点数比较</li>
<li>要注意浮点数中一些特殊值的处理</li>
</ol>
<h3>第四章 字符集</h3>
<h4>4.1 字符集概述</h4>
<p>字符集是一套符号和编码的规则</p>
<h4>4.2 MySql支持字符集简介</h4>
<pre><code class="language-txt" data-comment="">mysql&gt; show character set;</code></pre>
<p>mysql的字符集包括:</p>
<p><code class="inline-code">字符集</code>(character): 定义mysql存储字符串的方式</p>
<p><code class="inline-code">校对规则</code>(collation): 定义了比较字符串的方式</p>
<p>字符集和校对规则是一对多的关系,MySql支持30多种字符集和70多种校对规则</p>
<p>每种字符集至少对应一个校对规则</p>
<pre><code class="language-txt" data-comment="">mysql&gt; show collation like 'utf8%';
</code></pre>
<h4>4.3 Unicode简述</h4>
<p>Unicode是一种编码规范,也是一种字符编码方法,可以容纳全世界所有语言文字的编码方案。</p>
<h4>4.4 怎样选择合适的字符集</h4>
<p>能够完全满足应用的前提下,尽量使用小的字符集。</p>
<h4>4.5 MySql字符集的设置</h4>
<p>mysql的字符集和校对规则有四个级别的默认设置: <code class="inline-code">服务器级</code>、<code class="inline-code">数据库级</code>、<code class="inline-code">表级</code>和<code class="inline-code">字段级</code></p>
<pre><code class="language-txt" data-comment="">vim my.cnf
[mysqld]
default-character-set=utf8
or
mysqld --default-character-set=utf8
or
./configure --with-charset=utf8</code></pre>
<p>查询当前服务器的字符集和校对规则</p>
<pre><code>mysql&gt; show variables like 'character_set_server';</code></pre>
<h3>第五章 索引的设计和使用</h3>
<h4>5.1 MySql索引概述</h4>
<p>所有MySql列类型可以被索引。</p>
<p>索引总是对整个列进行,不支持局部(前缀)索引。</p>
<h4>5.2 设计索引的原则</h4>
<ul>
<li>搜索的索引列,不一定是所要选择的列</li>
<li>
<p>使用唯一索引</p>
<p>对于唯一值的列,索引的效果最好,而具有多个重复值的列,其索引效果最差</p>
</li>
<li>使用短索引</li>
<li>利用最左前缀</li>
<li>不要过度索引</li>
<li>考虑在列上进行的比较类型</li>
</ul>
<h4>5.3 btree索引与hash索引</h4>
<p>下列范围查询只用月btree索引和hash索引</p>
<pre><code class="language-sql" data-comment="">select * from t1 where key_col = 1 or key_col in (1, 2, 3);</code></pre>
<p>下列范围查询适用于btree索引</p>
<pre><code class="language-sql" data-comment="">select * from t1 where key_col &gt; 1 and key_col &lt; 10;
select * from t1 where key_col like 'ab%' or key_col between 'bar' and 'foo';</code></pre>
<h4>5.4 MySql如何使用索引</h4>
<p>大多数mysql索引(primary key、unique、index和fulltext)在b树中存储,只是空间列类型的
索引引用r-树,并且memory表还支持hash索引</p>
<h3>第六章 锁机制和事务控制</h3>
<h4>6.1 如何加锁</h4>
<pre><code class="language-txt" data-comment="">加锁
lock tables 
    tbl_name [as alias] { read [local] | [low_priority] where}
    [, tbl_name [as alias] { read [local] | [low_priority] where} ] ...

解锁
unlock tables</code></pre>
<p>InnoDB的存储引擎提供行级锁,支持共享锁和排他锁,以及四种不同的隔离级别</p>
<h4>6.2 死锁</h4>
<p>InnoDB自动检测事务的死锁,并回滚一个或几个事务来防止死锁。</p>
<p>不推荐在一个事务中混合更新不同存储类型的表,也不推荐相同类型的表采用不同的锁定方式加锁</p>
<h4>6.3 事务控制</h4>
<pre><code class="language-txt" data-comment="">start transaction | begin [work]
commit [work] [and [no] chain] [[no] release]
rollback [work] [and [no] chain] [[no] release]
set autocommit = {0|1}</code></pre>
<p>所有的ddl语句是不能回滚的,并且部分的ddl语句会造成隐式的提交。</p>
<p>在事务中可以通过定义savepoint,指定回滚事务的一个部分,但是不能指定提交事务的一个部分</p>
<h3>第七章 SQL的安全问题</h3>
<h4>7.1 SQL注入简述</h4>
<p>SQL Injection原理: 利用某些数据库的外部接口把用户数据插入到实际的数据库操作语言中,
从而达到入侵数据库乃至操作系统的目的</p>
<h4>7.3 开发中可以采取的措施</h4>
<ul>
<li>prepareStatement + bind-variable</li>
<li>使用应用程序提供的转换函数</li>
<li>自己定义函数进行校验
<ul>
<li>整理数据使之变得有效</li>
<li>拒绝已知的非法输入</li>
<li>只接受已知的合法输入</li>
</ul></li>
</ul>
<h3>第八章 SQL Mode及相关问题</h3>
<h4>8.1 MySql SQL Mode 简介</h4>
<p>定义了mysql应支持的SQL语法,以及应该在数据上执行何种确认检查</p>
<pre><code class="language-txt" data-comment="">set [session|global] sql_mode='modes'</code></pre>
<p>常用的sql_mode</p>
<ol>
<li>ANSI: 更改语法和行为,使其更符合标准SQL</li>
<li>STRICT_TRANS_TABLES: 如果不能将给定的值插入到事务中,则放弃该语句</li>
<li>TRADITIONAL: make mysql的行为向&quot;传统&quot;SQL数据库系统。该模式的简单描述是当在列中插入不正确
的值时&quot;给出错误而不是警告&quot;。</li>
</ol>
<h4>8.2 SQL Mode与可移植性</h4>
<h4>8.3 SQL Mode与数据校验</h4>
<p>SQL Mode可以实现对数据校验和转移等功能</p>
<ul>
<li>校验日期数据的合法性</li>
<li>在insert或update过程中,如果被0除,则产生错误</li>
<li>将'&quot;'视为识别符('`'引号字符)</li>
<li>禁用反斜杠作为字符串的退出字符,启用NO_BACKSLASH_ESCAPES模式,反斜杠则为普通字符</li>
<li>将||视为字符串连接操作符(+),而不视为or</li>
</ul>
<h3>第九章 常用SQL技巧</h3>
<h4>9.1 检索包含最大/最小值的行</h4>
<pre><code class="language-sql" data-comment="">select student_name, min(test_score), max(test_score) from student group by student_name;</code></pre>
<h4>9.2 巧用rand()/rand(h)提取随机行</h4>
<pre><code class="language-sql" data-comment="">; 随机顺序检索数据行
select * from tbl_name order by rand();
select * from table1, tabl2 where a=b and c&lt;d order by rand() limit 1000;</code></pre>
<h4>9.3 利用group by 的with rollup子句做统计</h4>
<pre><code class="language-sql" data-comment="">select year, country, product, sum(profix) from sales group by year, country, product with rollup 
limit 5;</code></pre>
<p>rollup和order by互相排斥</p>
<h4>9.4 用bit group functions做统计</h4>
<pre><code class="language-sql" data-comment="">select cust_type, bit_or(id) from ta group by cust_type;
select cust_type, bit_and(id) from ta group by cust_type;

;每个月的访问天数
SELECT year,month,BIT_COUNT(BIT_OR(1&lt;&lt;day)) AS days FROM t1 GROUP BY year,month;</code></pre>
<h3>第十章 其他需注意的问题</h3>
<h4>10.1 数据库名、表名大小写问题</h4>
<h4>10.2 使用外键需注意的地方</h4>
<p>在mysql中,InnoDB表支持对外部关键字约束条件的检查。</p>
<h2>第二篇 优化篇</h2>
<h3>第十一章 SQL优化</h3>
<h4>11.1 优化SQL的一般步骤</h4>
<ul>
<li>通过show status和应用特点了解各种SQL的执行频率
<ul>
<li>Com_select 执行select的次数</li>
<li>Com_insert 执行insert的次数</li>
<li>Com_update 执行update的次数</li>
<li>Com_delete 执行delete的次数</li>
<li>Innodb_rows_read select返回的行数</li>
<li>Innodb_rows_inserted insert插入的行数</li>
<li>Innodb_rows_updated update更新的行数</li>
<li>Innodb_rows_deleted delete删除的行数</li>
<li>connections 试图连接mysql服务器的次数</li>
<li>uptime 服务器工作时间</li>
<li>slow_queries 慢查询的次数</li>
</ul></li>
<li>定位执行效率较低的SQL语句
<ul>
<li>通过慢查询日志定位那些执行效率较低的SQL语句</li>
<li>使用show processlist命令查看当前mysql在进行的线程</li>
</ul></li>
<li>使用explain分析低效SQL的执行计划
<ul>
<li>select_type select类型</li>
<li>table 输出结果集的表</li>
<li>type 表示表的连接类型(system、ref、all...)</li>
<li>possible_keys 表示查询时,可以使用的索引列</li>
<li>keys 表示使用的索引</li>
<li>key_len 索引的长度</li>
<li>rows 扫描范围</li>
<li>Extra 执行情况的说明和描述</li>
</ul></li>
<li>确定问题,并采取相当的优化措施</li>
</ul>
<h4>11.2 索引问题</h4>
<ul>
<li>索引的存储分类</li>
</ul>
<p>myisam表的数据文件和索引文件是自动分开的;</p>
<p>innodb的数据和索引是存储在一个表空间里面,但可以有多个文件组成</p>
<p>索引的存储类型目前只有btree和hash,与表的模式相关</p>
<p>myisam-》btree、innodb-》btree、memory/heap-》hash、btree</p>
<p>mysql目前不支持函数索引,只能对列的前一部分进行索引</p>
<pre><code class="language-sql" data-comment="">create index ind_test on table1(name(5));</code></pre>
<ul>
<li>mysql如何使用索引</li>
</ul>
<p>下列情况下,mysql不会使用已有的索引</p>
<ol>
<li>如果么mysql估计索引比扫描全表更慢</li>
<li>如果使用heap表并且where条件中不用=索引列,其他&gt;,&lt;,&gt;=,&lt;=均不适用索引</li>
<li>如果不是索引列的第一部分</li>
<li>如果like是以%开始的</li>
<li>对where后边条件为字符串的一定要加引号,字符串如果是数字mysql会自动转为
字符串,但是不使用索引</li>
</ol>
<ul>
<li>查看索引的使用情况</li>
</ul>
<p>如果索引正在工作,handler_read_key的值将很高</p>
<p>如果索引运行低效,则handler_read_rnd_next的值将较高</p>
<pre><code class="language-sql" data-comment="">show status like 'Handler_read%';</code></pre>
<h4>11.3 两个简单实用的优化方法</h4>
<ul>
<li>定期分析表
<ul>
<li>analyze table 用于肥西和存储表的关键字分布</li>
<li>check table 检查一个或多个表是否由错误</li>
<li>checksum table 报告一个表校验和</li>
</ul></li>
<li>使用optimize table 重新利用未使用的空间,并整理数据文件的碎片</li>
</ul>
<h4>11.4 常用SQL的优化</h4>
<ul>
<li>大批量插入数据</li>
</ul>
<ol>
<li>对于myisam,
<pre><code class="language-sql" data-comment="">alter table tblname disable keys;
; loading the data
; ...
alter table tblname enable keys;</code></pre></li>
<li>对于innodb
2.1 将导入的数据按照主键的顺序排列
2.2 在导入数据前执行<code class="inline-code">set unique_check=0;</code>,关闭唯一性校验,导入后执行<code class="inline-code">set unique_check=1;</code>
2.3 导入前执行<code class="inline-code">set autocommit=0;</code>,关闭自动提交,导入结束后执行<code class="inline-code">set autocommit=1;</code></li>
</ol>
<ul>
<li>优化insert语句</li>
</ul>
<ol>
<li>同一客户数据批量插入
<pre><code class="language-sql" data-comment="">insert into test values(1, 2), (1, 3), (1, 4)...</code></pre></li>
<li>不同客户使用insert delayed</li>
<li>将索引文件和数据文件分在不同的磁盘存放</li>
<li>批量插入,可增加bulk_insert_buffer_size变量值(只能用与myisam)</li>
<li>从一个文本文件装载一个表时,使用<code class="inline-code">load data infile</code></li>
<li>根据情况使用replace替代insert</li>
<li>根据情况使用ignore关键字忽略重复记录</li>
</ol>
<ul>
<li>
<p>优化group by语句
默认情况下,mysql排序所有group by col1,col2,...可以使用order by null禁止排序</p>
<pre><code class="language-sql" data-comment="">insert into foo select a, count(*) from bar group by a order by null;</code></pre>
</li>
<li>优化order by语句</li>
</ul>
<p>下列sql可以使用索引:</p>
<pre><code class="language-sql" data-comment="">select * from t1 order by key_part1, key_part2, ...;
select * from t1 where key_part1 order by key_part1 desc, key_part2 desc;
select * from t1 order by key_part1 desc, key_part2 desc;</code></pre>
<p>下列则不适用索引:</p>
<pre><code># order by的字段混合asc和deesc
select * from t1 order by key_part1 desc, key_part2 asc;
# 用于查询行的关键字与order by中使用的不相同
select * from t1 where key2=constant order by key1;
# 对不同的关键字使用order by
select * from t1 order by key1, key2;</code></pre>
<ul>
<li>优化join语句</li>
</ul>
<p>查询所有没有订单记录的用户</p>
<pre><code class="language-sql" data-comment=""># 子查询
select * from customerinfo where customerid not in (select customerid from salesinfo);
# join 更有效率(不需要临时表)
select * from customerinfo left join salesinfo on customerinfo.customerid=salesinfo.customerid
where salesinfo.customerid is null</code></pre>
<ul>
<li>优化or</li>
</ul>
<p>如果要利用索引,则or之间的每个条件列都要加索引</p>
<ul>
<li>查询优先还是更新优先</li>
</ul>
<p>对于innodb,语句的执行是由获得行锁的顺序决定的</p>
<p>mysql默认的调度策略</p>
<ol>
<li>写入操作优先于读取操作</li>
<li>对某张表写入同一时刻只能发生一次,按照到达的顺序处理</li>
<li>读取可以多个操作同时进行</li>
</ol>
<p>修改调度(myisam)</p>
<ol>
<li>low_priority(delete, insert, load data, replace, update)</li>
<li>high_priority(select, insert)</li>
<li>delayed(insert, replace)</li>
</ol>
<ul>
<li>使用sql提示</li>
</ul>
<p><code class="inline-code">select sql_buffer_results ...</code> 强制mysql生成一个临时结果集,尽早释放各种锁</p>
<ol>
<li>use index 提供给你希望mysql去参考的索引列表,让mysql不再考虑其他可用的索引</li>
<li>ignore index 让mysql忽略一个或多个索引</li>
<li>force index 强制指定索引</li>
</ol>
<ul>
<li>其他优化措施</li>
</ul>
<ol>
<li>使用持久的链接数据库避免连接开销</li>
<li>经常检查所有查询确实使用了必要的索引</li>
<li>避免在频繁更新的表中执行复杂的select查询</li>
<li>对没有删除操作的myisam表,插入和查询可以并行进行</li>
<li>充分利用列有默认值的事实</li>
<li>对经常访问的可以重构的数据使用内存表</li>
<li>通过复制可以提高某些操作的性能</li>
<li>表字段尽量不适用自增长变量</li>
</ol>
<h3>第十二章 优化数据库对象</h3>
<h4>12.1 优化表的数据类型</h4>
<p><code class="inline-code">select * from tbl_name procedure analyse();</code>输出的每一列信息都会对数据表中的列
的数据类型体会优化建议。<code class="inline-code">select * from tbl_name procedure analyse(16, 256)</code>不要
为那些包含的值对于16个或者256字节的enum类型提出建议。</p>
<h4>12.2 通过拆分,提高表的访问效率</h4>
<ol>
<li>纵向拆分</li>
</ol>
<p>按照应用访问的频度,将表中经常访问的字段和不经常访问的字段拆分分成两个表,经常访问的字段
尽量定长的,这要可以有效的提高表的查询和更新的频率。</p>
<ol start="2">
<li>横向拆分</li>
</ol>
<p>按照应用的情况,有目的的将数据横拆成几个表,或通过分区分到多个分区中</p>
<h4>12.3 逆规范化</h4>
<p>适当冗余数据提高效率</p>
<h4>12.4 使用冗余统计表</h4>
<p>对于大表的统计分析,如果统计的数据量不大,利用insert...select将数据移到临时表
中比直接在大表上做统计要效率更高</p>
<h4>12.5 选择更合适的表类型</h4>
<h6>2018.02.26</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>