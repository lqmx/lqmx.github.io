<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520260298">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第六章 锁</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520260298">
    <link rel="stylesheet" href="../../css/reset.css?v1520260298">
    <link rel="stylesheet" href="../../css/md.css?v1520260298">
    <link rel="stylesheet" href="../../css/module.css?v1520260298">
    <link rel="stylesheet" href="../../css/c.css?v1520260298">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520260298">
    <script src="../../dep/require.js?1520260298"></script>
</head>
<body>
    <div class="md"><h1>第六章 锁</h1>
<h6>2018.03.05</h6>
<h2>6.1 什么是锁</h2>
<p>锁机制用于管理对共享资源的并发访问。</p>
<h2>6.2 lock与latch</h2>
<p>latch一般称为闩锁(轻量级的锁),因为其要求锁定的时间非常短。在InnoDB中,latch分为mutex(互斥量)
和rwlock(读写锁)。其目的用来保证并发线程操作临界资源的正确性,并且没有死锁检查的机制。</p>
<p>lock的对象是事务,用来锁定的是数据库中的对象,如表、页、行。并且一般lock的对象仅在事务
commit或rollback后释放(不同事务隔离级别释放的时间可能不同)。lock有死锁检查机制。</p>
<table>
<thead>
<tr>
<th></th>
<th>lock</th>
<th>latch</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象</td>
<td>事务</td>
<td>线程</td>
</tr>
<tr>
<td>保护</td>
<td>数据库内容</td>
<td>内存数据结构</td>
</tr>
<tr>
<td>持续时间</td>
<td>整个事务过程</td>
<td>临界资源</td>
</tr>
<tr>
<td>模式</td>
<td>行锁、表锁、意向锁</td>
<td>读写锁、互斥量</td>
</tr>
<tr>
<td>死锁</td>
<td>通过waits-for graph、time out等机制进行死锁检查与处理</td>
<td>无死锁检测与处理。仅通过应用程序加锁的顺序保证无死锁的情况发生</td>
</tr>
<tr>
<td>存在于</td>
<td>Lock Manager的哈希表中</td>
<td>每个数据结构的对象中</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql" data-comment="">show engine innodb mutex;</code></pre>
<h2>6.3 InnoDB存储引擎中的锁</h2>
<h3>6.3.1 锁的类型</h3>
<p>InnoDB实现了两种标准的行级锁:</p>
<ul>
<li>共享锁(S Lock),允许事务读一行数据。</li>
<li>排他锁(X Lock),允许事务删除或更新一行数据。</li>
</ul>
<p><code class="inline-code">锁兼容</code>:如果一个事务t1获取了行r的共享锁,其他事务t2也可以立即获得行r的共享锁,因为读取没有改变行r的数据。</p>
<p><code class="inline-code">锁不兼容</code>:其他事务t3想获得行r的排它锁,必须等待事务t1,t2释放行r的共享锁。</p>
<p>排他锁和共享锁的兼容性</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<p>InnoDB支持多粒度锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在。</p>
<p><code class="inline-code">意向锁</code>: 将锁定的对象分为多个层次,意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>如果需要对页上的记录r进行上锁X,那么分别需要对数据库、表、页上意向锁IX,最后对记录r上锁X。</p>
<p>支持两种意向锁:</p>
<ul>
<li>意向共享锁(IS Lock),事务想要获得一张表中某几行的共享锁</li>
<li>意向排它锁(IX Lock),事务想要获得一张表中某几行的排它锁</li>
</ul>
<p>InnoDB锁的兼容性</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql" data-comment="">show engine innodb status;</code></pre>
<pre><code class="language-mysql" data-comment="">select * from information_schema.innodb_trx;
select * from information_schema.innodb_locks;
select * from information_schema.innodb_lock_waits;
select 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
from information_schema.innodb_lock_waits w
inner join information_schema.innodb_trx b
on b.trx_id=w.blocking_trx_id
inner join information_schema.innodb_trx r
on r.trx_id=w.requestion_trx_id;</code></pre>
<h3>6.3.2 一致性非锁定读</h3>
<p>一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。
如果读取的行正在执行delete或update操作,这时读取操作不会因此去等待行上的锁的释放。而是去
读取行的一个快照数据。</p>
<p>在事务隔离级别为READ COMMITTED和REPEATABLE READ下,InnoDB使用非锁定一致性读。在READ
COMMITTED事务隔离级别下,对于快照数据,总是读取被锁定行的最新一份快照数据。而在REPEATABLE
READ事务隔离级别下,对于快照数据,总是读取事务开始时的行数据版本。</p>
<h3>6.3.3 一致性锁定读</h3>
<p>InnoDB对于SELECT语句支持两种一致性的锁定读操作</p>
<ul>
<li>SELECT ... FOR UPDATE</li>
<li>SELECT ... LOCK IN SHARE MODE</li>
</ul>
<p>第一种会给行记录加一个X锁,其他事务不能对已锁定的行加任何锁。
第二种对行记录加一个S锁,其他事务可以向锁定的行加S锁,如果加X锁则会被阻塞</p>
<h3>6.3.4 自增长与锁</h3>
<p>在InnoDB的内存结构中,对每个含有自增长值的表都有一个自增长计数器,当对含有自增长计数器的表进行
插入时,这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式
较AUTO-INC Locking。这种锁采用一种特殊的表锁机制,为了提高插入性能,锁不是在事务完成后释放,
而是在完成对自增长值插入的SQL语句后立即释放。</p>
<p><code class="inline-code">innodb_autoinc_lock_mode</code>可以控制自增长的模式。</p>
<p>在InnoDB中,自增长值的列必须是索引,同时必须是索引的第一个列。</p>
<h3>6.3.6 外键和锁</h3>
<p>对于外键值的插入或更新,首先需要查询父表中的记录,即SELECT父表。使用的是SELECT ... LOCK IN SHARE MODE方式
,主动对附表加一个S锁。</p>
<h2>6.4 锁的算法</h2>
<h3>6.4.1 行锁的三种算法</h3>
<ul>
<li>Record Lock: 单个行记录上的锁</li>
<li>Gap Lock: 间隙锁,锁定一个范围,但不包含记录本身</li>
<li>Next-Key Lock: Gap Lock + Record Lock,锁定一个范围,并且锁定记录本身</li>
</ul>
<p>采用Next-Key Lock的锁定技术称为Next-Key Locking。其设计目的是为了解决Phantom Problem。</p>
<p>当查询的索引含有唯一属性时,InnoDB会对Next-Key Lock进行优化,将其降级为Record Lock,即
仅锁住索引本身,而不是范围。</p>
<p>Gap Lock的作用是阻止多个事务将记录插入到同一范围内,而这会导致Phantom Problem问题的产生。</p>
<p>用户可以通过两种方式显式关闭Gap Lock</p>
<ul>
<li>将事务的隔离级别设置为READ COMMITTED</li>
<li>将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ul>
<h3>6.4.2 解决Phantom Problem</h3>
<p>Phantom Problem是指在同一个事务下,连续执行两次相同的SQL语句可能导致不同的结果,第二次
的SQL语句可能会返回之前不存在的行。</p>
<h3>6.5 锁问题</h3>
<h6>2018.03.05</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>