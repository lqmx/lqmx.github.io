<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520342435">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第六章 锁</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520342435">
    <link rel="stylesheet" href="../../css/reset.css?v1520342435">
    <link rel="stylesheet" href="../../css/md.css?v1520342435">
    <link rel="stylesheet" href="../../css/module.css?v1520342435">
    <link rel="stylesheet" href="../../css/c.css?v1520342435">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520342435">
    <script src="../../dep/require.js?1520342435"></script>
</head>
<body>
    <div class="md"><h1>第六章 锁</h1>
<h6>2018.03.05</h6>
<h2>6.1 什么是锁</h2>
<p>锁机制用于管理对共享资源的并发访问。</p>
<h2>6.2 lock与latch</h2>
<p>latch一般称为闩锁(轻量级的锁),因为其要求锁定的时间非常短。在InnoDB中,latch分为mutex(互斥量)
和rwlock(读写锁)。其目的用来保证并发线程操作临界资源的正确性,并且没有死锁检查的机制。</p>
<p>lock的对象是事务,用来锁定的是数据库中的对象,如表、页、行。并且一般lock的对象仅在事务
commit或rollback后释放(不同事务隔离级别释放的时间可能不同)。lock有死锁检查机制。</p>
<table>
<thead>
<tr>
<th></th>
<th>lock</th>
<th>latch</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象</td>
<td>事务</td>
<td>线程</td>
</tr>
<tr>
<td>保护</td>
<td>数据库内容</td>
<td>内存数据结构</td>
</tr>
<tr>
<td>持续时间</td>
<td>整个事务过程</td>
<td>临界资源</td>
</tr>
<tr>
<td>模式</td>
<td>行锁、表锁、意向锁</td>
<td>读写锁、互斥量</td>
</tr>
<tr>
<td>死锁</td>
<td>通过waits-for graph、time out等机制进行死锁检查与处理</td>
<td>无死锁检测与处理。仅通过应用程序加锁的顺序保证无死锁的情况发生</td>
</tr>
<tr>
<td>存在于</td>
<td>Lock Manager的哈希表中</td>
<td>每个数据结构的对象中</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql" data-comment="">show engine innodb mutex;</code></pre>
<h2>6.3 InnoDB存储引擎中的锁</h2>
<h3>6.3.1 锁的类型</h3>
<p>InnoDB实现了两种标准的行级锁:</p>
<ul>
<li>共享锁(S Lock),允许事务读一行数据。</li>
<li>排他锁(X Lock),允许事务删除或更新一行数据。</li>
</ul>
<p><code class="inline-code">锁兼容</code>:如果一个事务t1获取了行r的共享锁,其他事务t2也可以立即获得行r的共享锁,因为读取没有改变行r的数据。</p>
<p><code class="inline-code">锁不兼容</code>:其他事务t3想获得行r的排它锁,必须等待事务t1,t2释放行r的共享锁。</p>
<p>排他锁和共享锁的兼容性</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<p>InnoDB支持多粒度锁定,这种锁定允许事务在行级上的锁和表级上的锁同时存在。</p>
<p><code class="inline-code">意向锁</code>: 将锁定的对象分为多个层次,意向锁意味着事务希望在更细粒度上进行加锁。</p>
<p>如果需要对页上的记录r进行上锁X,那么分别需要对数据库、表、页上意向锁IX,最后对记录r上锁X。</p>
<p>支持两种意向锁:</p>
<ul>
<li>意向共享锁(IS Lock),事务想要获得一张表中某几行的共享锁</li>
<li>意向排它锁(IX Lock),事务想要获得一张表中某几行的排它锁</li>
</ul>
<p>InnoDB锁的兼容性</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql" data-comment="">show engine innodb status;</code></pre>
<pre><code class="language-mysql" data-comment="">select * from information_schema.innodb_trx;
select * from information_schema.innodb_locks;
select * from information_schema.innodb_lock_waits;
select 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
from information_schema.innodb_lock_waits w
inner join information_schema.innodb_trx b
on b.trx_id=w.blocking_trx_id
inner join information_schema.innodb_trx r
on r.trx_id=w.requestion_trx_id;</code></pre>
<h3>6.3.2 一致性非锁定读</h3>
<p>一致性非锁定读是指InnoDB存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。
如果读取的行正在执行delete或update操作,这时读取操作不会因此去等待行上的锁的释放。而是去
读取行的一个快照数据。</p>
<p>在事务隔离级别为READ COMMITTED和REPEATABLE READ下,InnoDB使用非锁定一致性读。在READ
COMMITTED事务隔离级别下,对于快照数据,总是读取被锁定行的最新一份快照数据。而在REPEATABLE
READ事务隔离级别下,对于快照数据,总是读取事务开始时的行数据版本。</p>
<h3>6.3.3 一致性锁定读</h3>
<p>InnoDB对于SELECT语句支持两种一致性的锁定读操作</p>
<ul>
<li>SELECT ... FOR UPDATE</li>
<li>SELECT ... LOCK IN SHARE MODE</li>
</ul>
<p>第一种会给行记录加一个X锁,其他事务不能对已锁定的行加任何锁。
第二种对行记录加一个S锁,其他事务可以向锁定的行加S锁,如果加X锁则会被阻塞</p>
<h3>6.3.4 自增长与锁</h3>
<p>在InnoDB的内存结构中,对每个含有自增长值的表都有一个自增长计数器,当对含有自增长计数器的表进行
插入时,这个计数器会被初始化。插入操作会依据这个自增长的计数器值加1赋予自增长列。这个实现方式
较AUTO-INC Locking。这种锁采用一种特殊的表锁机制,为了提高插入性能,锁不是在事务完成后释放,
而是在完成对自增长值插入的SQL语句后立即释放。</p>
<p><code class="inline-code">innodb_autoinc_lock_mode</code>可以控制自增长的模式。</p>
<p>在InnoDB中,自增长值的列必须是索引,同时必须是索引的第一个列。</p>
<h3>6.3.6 外键和锁</h3>
<p>对于外键值的插入或更新,首先需要查询父表中的记录,即SELECT父表。使用的是SELECT ... LOCK IN SHARE MODE方式
,主动对附表加一个S锁。</p>
<h2>6.4 锁的算法</h2>
<h3>6.4.1 行锁的三种算法</h3>
<ul>
<li>Record Lock: 单个行记录上的锁</li>
<li>Gap Lock: 间隙锁,锁定一个范围,但不包含记录本身</li>
<li>Next-Key Lock: Gap Lock + Record Lock,锁定一个范围,并且锁定记录本身</li>
</ul>
<p>采用Next-Key Lock的锁定技术称为Next-Key Locking。其设计目的是为了解决Phantom Problem。</p>
<p>当查询的索引含有唯一属性时,InnoDB会对Next-Key Lock进行优化,将其降级为Record Lock,即
仅锁住索引本身,而不是范围。</p>
<p>Gap Lock的作用是阻止多个事务将记录插入到同一范围内,而这会导致Phantom Problem问题的产生。</p>
<p>用户可以通过两种方式显式关闭Gap Lock</p>
<ul>
<li>将事务的隔离级别设置为READ COMMITTED</li>
<li>将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ul>
<h3>6.4.2 解决Phantom Problem</h3>
<p>Phantom Problem是指在同一个事务下,连续执行两次相同的SQL语句可能导致不同的结果,第二次
的SQL语句可能会返回之前不存在的行。</p>
<h2>6.5 锁问题</h2>
<h3>6.5.1 脏读</h3>
<p>脏数据:事务对缓冲池中行记录的修改,还没有被提交</p>
<p>脏读的示例</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>set @@tx_isolation='read-uncommitted';</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>set @@tx_isolation='read-uncommitted';</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>select * from t</td>
</tr>
<tr>
<td>5</td>
<td>insert into t select 2</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>select * from t</td>
</tr>
</tbody>
</table>
<p>脏读发生的条件至少是需要事务的隔离级别为READ UNCOMMITTED</p>
<h3>6.5.2 不可重复读</h3>
<p>不可重复读是指一个事务内多次读取同一数据集合,在这个事务还没有结束的时候,另外一个事务也访问
了该同一数据集合,并做了一些DML操作。</p>
<p>脏读是未提交的数据,不可重复读是提交的数据</p>
<p>不可重复读示例</p>
<p>| Time | Session A | Session B |
| 1 | set @@tx_isolation='read-committed |   |
| 2 |   | set @@tx_isolation='read-committed |
| 3 | begin | begin |
| 4 | select <em> from t |   |
| 5 |   | insert into t select 2 |
| 6 |   | commit |
| 7 | select </em> from t |   |</p>
<p>一般来说,不可重复读是可以接受的,因为读到的是已经提交的数据,本身不会带来什么问题。</p>
<p>InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE,采用Next-Key Lock算法,避免了不可重复读的现象</p>
<h3>6.5.3 丢失更新</h3>
<p>丢失更新是另外一个锁导致的问题,就是一个事务的更新操作会被另外一个事务的更新操作所覆盖,从而
到时数据不一致</p>
<ul>
<li>事务1查询一行数据,放入本地内存,显示给一个终端用户user1</li>
<li>事务2查询这个记录,显示给终端用户user2</li>
<li>user1修改了这行记录,更新并提交</li>
<li>user2修改了这行记录,更新并提交</li>
</ul>
<p>丢失更新问题的处理</p>
<p>| Time | Session A | Session B |
| 1 | begin |   |
| 2 | select cash into @cash from account where user=pUser for update  |   |
| 3 |   | select cash into @cash from account where user=pUser for update; -- 等待 |
|   | ... | ... |
| m | update account set cash=@cash-9000 where user=pUser |   |
| m+1 | commit |   |
| m+2 |   | update account set cash=@cash-1 where user=pUser |
| m+3 |   | commit |</p>
<h2>6.6 阻塞</h2>
<p>因为不同锁之间的兼容性关系,在有些时刻一个事务中的锁需要等待另外一个事务中的锁释放它所占用的资源,
这就是阻塞</p>
<p><code class="inline-code">innodb_lock_wait_time</code>:控制等待的时间(动态参数)</p>
<p><code class="inline-code">innodb_rollback_on_timeout</code>:设定是否在超时时对进行中事务进行回滚操作</p>
<p>当发生超时时,数据库会抛出一个1205的错误</p>
<h2>6.7 死锁</h2>
<h3>6.7.1 死锁的概念</h3>
<p>死锁是指两个或两个以上的事务正在执行过程中,因争夺锁资源而造成的一种相互等待的现象。</p>
<p>解决死锁最简单的一种方法是超时,<code class="inline-code">innodb_lock_wait_time</code></p>
<p>当前数据库还普遍采用wait-for graph(等待图)的方式来进行死锁检测。</p>
<p>wait-for graph要求数据库保存以下两种信息:</p>
<ul>
<li>锁的信息链表</li>
<li>事务等待链表</li>
</ul>
<h3>6.7.2 死锁概率</h3>
<p>n+1个事务,每个事务r+1个操作,每个操作从R行数据随机操作一行数据</p>
<p>一个事务发生死锁的概率 约等于 nrr/(2R)</p>
<p>系统中任何一个事务发生死锁的改路 约等于 nnrrrr/(4RR)</p>
<ul>
<li>系统中事务的数量越多发生死锁的概率越大</li>
<li>每个事务操作的数量越多,发生死锁的概率越大</li>
<li>操作数据的集合越小,发生死锁的概率越大</li>
</ul>
<h3>6.7.3 死锁的示例</h3>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>begin</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from t where a = 1 for update;</td>
<td>begin</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>select * from t where a = 2 for update;</td>
</tr>
<tr>
<td>4</td>
<td>select * from t where a = 2 for update;</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>select * from t where a = 1 for update;</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Time</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>begin</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>begin</td>
</tr>
<tr>
<td>3</td>
<td>select * from t where a = 4 for update;</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>select * from t where a &lt;= 4 lock in share mode</td>
</tr>
<tr>
<td>5</td>
<td>insert into t values (3)</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>-- 事务获得锁,正常运行</td>
</tr>
</tbody>
</table>
<h2>6.8 锁升级</h2>
<p>锁升级是指将当前锁的粒度降低。</p>
<p>InnoDB不存在锁升级的问题</p>
<h2>6.9 小结</h2>
<h6>2018.03.06</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>