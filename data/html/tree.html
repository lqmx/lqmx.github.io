<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1521382600">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>数据结构 树</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1521382600">
    <link rel="stylesheet" href="../../css/reset.css?v1521382600">
    <link rel="stylesheet" href="../../css/md.css?v1521382600">
    <link rel="stylesheet" href="../../css/module.css?v1521382600">
    <link rel="stylesheet" href="../../css/c.css?v1521382600">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1521382600">
    <script src="../../dep/require.js?1521382600"></script>
</head>
<body>
    <div class="md"><h1>数据结构 树</h1>
<h6>2018.03.14</h6>
<h2>概念</h2>
<p>树是n(n&gt;=0)个节点的有限集</p>
<p>在任意一棵非空树种:</p>
<ol>
<li>有且仅有一个根节点</li>
<li>当n&gt;1时,其余节点可分为m(m&gt;0)个互不相交的有限集T1,T2,...。</li>
<li>子树,指父母节点的直接后代,不包含简介的。</li>
</ol>
<h3>节点的分类</h3>
<p>节点的度:节点拥有的子树数</p>
<p>叶节点:度为0的节点</p>
<p>内部节点:除根节点以外的分支节点</p>
<p>树的度:树内各节点的度的最大值</p>
<h3>节点的关系</h3>
<p>节点的孩子:根的子树是根的孩子</p>
<p>节点的双亲:子树的根是子树的双亲</p>
<p>兄弟:同一个双亲的孩子之间互称兄弟</p>
<p>节点的祖先:从根到该节点所经分支的所有节点</p>
<p>节点的子孙:以某节点为根的子树的所有节点是该节点的子孙</p>
<h3>其他概念</h3>
<p>节点的层次:从根开始,根为第一层,根的孩子为第二层</p>
<p>堂兄弟:双亲在同一层的节点互为堂兄弟</p>
<p>树的深度:树中节点的最大层次</p>
<p>有序树:树中各节点的子树看出是从左至右有次序的,不能互换的</p>
<p>森林:m(m&gt;=0)棵互不相交的树的集合</p>
<h2>树的存储结构</h2>
<h3>双亲表示法</h3>
<p>以一组连续空间存储树的节点,每个节点除存储数据之外,还会存储一个指向该节点
双亲的指示器。</p>
<pre><code class="language-c" data-comment="">#define MAX_TREE_SIZE 100
typedef int TElemType;
typedef struct PTNode {
    TElemType data;
    int parent;
} PTNode;
typedef struct {
    PTNode nodes[MAX_TREE_SIZE];
    int r, n;
} PTree;</code></pre>
<h3>孩子表示法</h3>
<pre><code class="language-c" data-comment="">#define MAX_TREE_SIZE 100
typedef struct CTNode {
    int child;
    struct CTNode *next;
} *ChildPtr;
typedef struct {
    TElemType data;
    ChildPtr firstChild;
} CTBox;
type struct {
    CTBox nodex[MAX_TREE_SIZE];
    int r, n;
} CTree;</code></pre>
<h3>孩子兄弟表示法</h3>
<pre><code class="language-c" data-comment="">typedef struct CSNode {
    TElemType data;
    struct CSNode *firstChild, *rightSib;
} CSNode, *CSTree;</code></pre>
<h2>树的应用</h2>
<h2>二叉树</h2>
<p>二叉树是n(n&gt;=0)个节点的有限结合,根节点有左子树和右子树,左右子树不相交,而且都是二叉树</p>
<h3>二叉树的特点</h3>
<ol>
<li>每个节点最多有两棵子树,度不大于2</li>
<li>节点的左子树和右子树是有顺序的,不能颠倒</li>
<li>即使结点只有一颗子树,也是有顺序的</li>
</ol>
<h3>特殊二叉树</h3>
<h4>斜树</h4>
<h4>满二叉树</h4>
<h4>完全二叉树</h4>
<h3>二叉树的性质</h3>
<h2>参考</h2>
<ul>
<li><a href="https://www.jianshu.com/p/45e056315c62">数据结构学习笔记之树</a></li>
</ul>
<h6>2018.03.18</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>