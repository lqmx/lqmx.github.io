<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1518354427">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>最小字符串编辑距离</title>
    <link rel="stylesheet" href="../../css/reset.css?v1518354427">
    <link rel="stylesheet" href="../../css/md.css?v1518354427">
    <link rel="stylesheet" href="../../css/module.css?v1518354427">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1518354427">
    <script src="../../dep/require.js?1518354427"></script>
</head>
<body>
<div class="md"><h1>最小字符串编辑距离</h1>
<h6>2018.01.24</h6>
<h2>问题描述</h2>
<blockquote class="bq5">
<p>给定两个字符串m和n，只允许进行如下三种操作：</p>
<ul>
<li>插入，例如：ab -&gt; abc</li>
<li>删除，例如：abc -&gt; ab</li>
<li>替换，例如：abc -&gt; abd</li>
</ul>
<p>那么请求出将m变成n的最小操作次数（也就是最小编辑距离）</p>
</blockquote>
<h2>解法</h2>
<pre><code>if len(m) = 0
    d[j][k] = len(n)
elseif  len(n) = 0
    d[j][k] = len(m)
else
    if m[j] == n[k] 
        d[j][k] = d[j - 1][k - 1]
    else
        d[j][k] = min(d[j - 1][k] + 1, d[j][k - 1] + 1, d[j - 1][k - 1] + 1)</code></pre>
<h3>递归</h3>
<pre><code class="language-php" data-comment="">function editDistanceRecursion($m, $n, $j, $k) {
    if($k == 0) {
        return $j;
    } elseif($j == 0) {
        return $k;
    } elseif ($m[$j - 1] == $n[$k - 1]) {
        return editDistanceRecursion($m, $n, $j - 1, $k - 1);
    } else {
        $insert = editDistanceRecursion($m, $n, $j - 1, $k) + 1;
        $delete = editDistanceRecursion($m, $n, $j, $k - 1) + 1;
        $replace = editDistanceRecursion($m, $n, $j - 1, $k - 1) + 1;
        return min($insert, $delete, $replace);
    }
}</code></pre>
<h3>动态规划</h3>
<pre><code class="language-php" data-comment="">function editDistanceDynamic($m, $n) {
    $j = count($m);
    $k = count($n);
    $d = array();

    for($p = 0; $p &lt;= $j; $p ++) {
        $d[$p] = array();
        $d[$p][0] = $p;
    }
    for($q = 0; $q &lt;= $k; $q ++) {
        $d[0][] = $q;
    }
    for($p = 1; $p &lt;= $j; $p ++) {
        for($q = 1; $q &lt;= $k; $q ++) {
            if($m[$p - 1] == $n[$q - 1]) {
                $d[$p][$q] = $d[$p -1][$q -1];
            } else {
                $insert = $d[$p - 1][$q] + 1;
                $delete = $d[$p][$q - 1] + 1;
                $replace = $d[$p - 1][$q - 1] + 1;
                $d[$p][$q] = min($insert, $delete, $replace);
            }
        }
    }
    return $d[$j][$k];
}</code></pre>
<h3>测试</h3>
<pre><code class="language-php" data-comment="">$ms = 'lmxqmx';
$ns = 'lqmx';

$m = str_split($ms);
$n = str_split($ns);
$j = count($m);
$k = count($n);

echo editDistanceRecursion($m, $n, $j, $k), PHP_EOL;
echo editDistanceDynamic($m, $n), PHP_EOL;</code></pre>
<h2>参考</h2>
<p><a href="http://blog.csdn.net/jinboker/article/details/78405881?locationNum=3&amp;fps=1">最小编辑距离问题</a></p>
<h6>2018.01.24</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>