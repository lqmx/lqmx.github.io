<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520159683">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第四章 表</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520159683">
    <link rel="stylesheet" href="../../css/reset.css?v1520159683">
    <link rel="stylesheet" href="../../css/md.css?v1520159683">
    <link rel="stylesheet" href="../../css/module.css?v1520159683">
    <link rel="stylesheet" href="../../css/c.css?v1520159683">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520159683">
    <script src="../../dep/require.js?1520159683"></script>
</head>
<body>
    <div class="md"><h1>第四章 表</h1>
<h6>2018.03.03</h6>
<h2>4.1 索引组织表</h2>
<p>InnoDB中,表都是根据主键顺序组织存放的,这种存储方式的表称为索引组织表。</p>
<p>每张表都有个主键,在创建表时如果没有显示定义主键,则会按如下方式选择或创建主键</p>
<ul>
<li>判断是否由非空的唯一索引,如果有则该列为主键</li>
<li>不符合上面条件,自动创建一个6字节大小的指针</li>
</ul>
<p>当表中有多个非空唯一索引时,将选择建表时第一个定义的非空唯一索引为主键。</p>
<h2>4.2 InnoDB逻辑存储结构</h2>
<p>所有数据都被逻辑地存放在一个空间中,称之为表空间,表空间又由段、区、页组成。</p>
<h3>4.2.1 表空间</h3>
<p>表空间内存放的只是数据、索引和插入缓冲Bitmap页,其他类的数据,如回滚信息,插入缓冲索引页、
系统事务信息,二次写缓冲等还是存放在原来的共享表空间内。</p>
<h3>4.2.2 段</h3>
<p>常见的段有数据段、索引段、回滚段等。</p>
<h3>4.2.3 区</h3>
<p>区是有连续页组成的空间,在任何情况下每个区的大小都为1MB。</p>
<p>在每个段开始时,先用32个大小的碎片页来存放数据,再使用完这些页之后才是64个连续页的申请。
这样做的目的是,对于一些小表,或是undo这类的段,可以在开始时申请较少的空间,节省磁盘容量的开销。</p>
<h3>4.2.4 页</h3>
<p>页是InnoDB磁盘管理的最小单位。</p>
<p>页的类型有:</p>
<ul>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制大对象页</li>
</ul>
<h3>4.2.5 行</h3>
<p>InnoDB是面向列的,也就是说数据是按行进行存放的。每个页存放的行记录也是有硬性定义的,最多允许
存放16KB/2-200行记录,即7992行记录。</p>
<h2>4.3 InnoDB行记录格式</h2>
<p>InnoDB提供了Compact和Redundant两种格式来存放行记录数据。</p>
<pre><code class="language-mysql" data-comment="">show table status like 'mytest';</code></pre>
<h3>4.3.1 Compact行记录格式</h3>
<p>Compact行记录存储格式:</p>
<table>
<thead>
<tr>
<th>变长字段长度列表</th>
<th>NULL标志位</th>
<th>记录头信息</th>
<th>列1数据</th>
<th>列2数据</th>
<th>...</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li>变长字段长度列表 逆序存放
<ul>
<li>该列长度小于255字节,用1字节表示</li>
<li>该列长度大于255字节,用2字节表示,最大两字节,因为varchar最大长度限制65535</li>
</ul></li>
<li>null标识位 有则用1表示</li>
<li>记录头信息
<ul>
<li>() 未知</li>
<li>() 未知</li>
<li>deleted_flag 该行是否已被删除</li>
<li>min_rec_flag 为1,如果该行记录是预先被定义为最小的记录</li>
<li>n_owned 该记录拥有的记录数</li>
<li>heap_no 索引堆中该记录的排序记录</li>
<li>record_type 记录类型,000表示普通,001表示B+树节点指针,010表示Infimum,011表示Supremum,1xx表示保留</li>
<li>next_record 页中下一条记录的相对位置</li>
</ul></li>
<li>列信息 有两个隐藏列:事务ID和回滚指针,若无主键,还有一个rowid列</li>
</ul>
<p>不管是char还是varchar,在compact格式下null值都不占用任何存储空间。</p>
<h3>4.3.2 Redundant行记录格式</h3>
<p>Redundant行记录存储格式:</p>
<table>
<thead>
<tr>
<th>字段长度偏移列表</th>
<th>记录头信息</th>
<th>列1数据</th>
<th>列2数据</th>
<th>...</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<ul>
<li>字段长度偏移列表 逆序放置</li>
<li>记录头信息
<ul>
<li>() 未知</li>
<li>() 未知</li>
<li>deleted_flag 该行是否已被删除</li>
<li>min_rec_flag 为1,如果该行记录是预先被定义为最小的记录</li>
<li>n_owned 该记录拥有的记录数</li>
<li>heap_no 索引堆中该记录的排序记录</li>
<li>n_fields 记录中列的数量</li>
<li>1byte_offs_flag 偏移列表为1字节还是2字节</li>
<li>next_record 页中下一条记录的相对位置</li>
</ul></li>
</ul>
<p>对于varchar类型的null值,redundant不占用任何存储空间,而char类型的null值需要占用空间。</p>
<h3>4.3.3 行溢出数据</h3>
<p>varchar(n)中的n指的是字符的长度,而文档说明类型最大支持65535,单位是字节,指所有varchar列
的长度总和。</p>
<p>对于行溢出数据,存放采用数据页面只保存varchar的前768字节的前缀数据,之后是偏移量,指向行
溢出页。</p>
<h3>4.3.4 Compressed和Dynamic行记录</h3>
<p>在对于存放BLOB中的数据采用了完全行溢出,数据页中只存放20个字节的指针,实际的数据存放在Off
Page中。</p>
<p>Compressed的另外一个功能:存储在其中的行数据会以zlib算法进行压缩。</p>
<h3>4.3.5 CHAR的行结构存储</h3>
<p>在不同的字符集下,char类型的列内部存储的可能不是定长的数据。</p>
<p>在多字节字符集的情况下,char和varchar的实际行存储基本是没有区别的。</p>
<h2>4.4 InnoDB数据页结构</h2>
<p>InnoDB数据页由以下7个部分组成</p>
<ul>
<li>File Header 文件头</li>
<li>Page Header 页头</li>
<li>Infimum和Supremum Records</li>
<li>User Records 用户记录,即行记录</li>
<li>Free Space 空闲空间</li>
<li>Page Directory 页目录</li>
<li>File Trailer 文件结尾信息</li>
</ul>
<h3>4.4.1 File Header</h3>
<p>File Header用来记录页的一些头信息。</p>
<h3>4.4.2 Page Header</h3>
<p>用来记录数据页的状态信息</p>
<h3>4.4.3 Infimum和Supremum Record</h3>
<p>虚拟行记录,用来限定记录的边界</p>
<p>Infimum记录是比该页任何主键值都要小的值</p>
<p>Supremum指比任何可能大的值还要大的值</p>
<h3>4.4.4 User Record和Free Space</h3>
<p>User Record即实际存储行记录的内容,InnoDB存储引擎表总是B+树索引组织的</p>
<p>Free Space即空闲空间,同样也是个链表数据结构,在一条记录被删除后,该空间会被加入到空闲链表中</p>
<h3>4.4.5 Page Directory</h3>
<p>Page Directory(页目录)存放记录的相对位置</p>
<p>Page Directory是一个稀疏目录</p>
<p>B+树索引并不能找到具体的一条记录,能找到的只是该记录所在的页。数据库把页载入到内存,然后
通过Page Directory在进行二叉查找。</p>
<p>Page Directory是逆序存放的。</p>
<h3>4.4.6 File Trailer</h3>
<p>检查页是否已经完整地写入磁盘。</p>
<p>在默认配置下,InnoDB存储引擎每次从磁盘读取一个页就会检测该页的完整性,即页是否发生Corrupt,
这就是通过File Trailer部分进行检测,该检测会有一定开销,可以用<code class="inline-code">innodb_checksums</code>来开启
或关闭对这个页完整性的检查。</p>
<h3>4.4.7 InnoDB数据页结构实例分析</h3>
<pre><code class="language-mysql" data-comment="">drop table if exists t;
create table t (
    a int unsigned not null auto_increment,
    b char(10),
    primary key(a)
) engine-innodb charset=utf8;
delimiter $$
create procedure load_t(count int unsigned)
begin
set @c=0;
while @c &lt; count do
    insert into t
    select null, repeat(char(97_read()*26), 10);
    set @c=@c+1;
end while;
end;
$$
delimiter;
call load_t(100);</code></pre>
<h2>4.5 Named File Formats机制</h2>
<p>从InnoDB 1.0.x版本开始,InnoDB存储通过Named File Formats机制来解决不同版本下页结构兼容性的问题。</p>
<p>InnoDB将1.0.x之前的文件格式定义为Antelope,将这个版本支持的文件格式定义为Barracuda。
新的文件格式总是包含于之前的版本的页格式。</p>
<pre><code class="language-mysql" data-comment="">-- 查看当前所使用的InnoDB存储引擎的文件格式
select @@version;
show variables like 'innodb_version';
show variables like 'innodb_file_format';</code></pre>
<h2>4.6 约束</h2>
<h3>4.6.1 数据完整性</h3>
<p>一般来说,数据完整性有一下三种形式:</p>
<ol>
<li>实体完整性保证表中有一个主键</li>
<li>域完整性保证数据每列的值满足特定的条件。
<ul>
<li>选择合适的数据类型确保一个数据值满足特定条件</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>考虑用default约束作为强制域完整性的一个方面</li>
</ul></li>
<li>参照完整性保证两张表的关系</li>
</ol>
<p>对于InnoDB本身而言,提供了下面几种约束:</p>
<ul>
<li>Primary Key</li>
<li>Unique Key</li>
<li>Foreign Key</li>
<li>Default</li>
<li>NOT NULL</li>
</ul>
<h3>4.6.2 约束的创建和查找</h3>
<ul>
<li>表建立时就进行约束定义</li>
<li>利用<code class="inline-code">alter table</code>命令来进行创建约束</li>
</ul>
<p>主键约束名为PRIMARY,唯一索引的默认约束名和列名相同</p>
<pre><code class="language-mysql" data-comment="">create table u (
    id int,
    name varchar(20),
    id_card char(18),
    primary key(id),
    unique key(name)
);
select constraint_name, constraint_type from information_schema.table_constraints
where table_schema='mytest' and table_name='u';
alter table u add unique key uk_id_caard(id_card);
select constraint_name, constraint_type from information_schema.table_constraints
where table_schema='mytest' and table_name='u';
create table p (
    id int, 
    u_id int,
    primary key(id),
    foreign key(u_id) references p(id)
);
select constraint_name, constraint_type from information_schema.table_constraints
where table_schema='mytest' and table_name='p';</code></pre>
<h3>4.6.3 约束和索引的区别</h3>
<p>当用户创建了一个唯一索引就创建了一个唯一的约束。但是约束和索引的概念不同,约束更是一个逻辑的
概念,用来保证数据的完整性,索引是一个数据结构,既有逻辑上的概念,在数据库中还代表着物理存储的方式。</p>
<h3>4.6.4 对错误数据的约束</h3>
<p>默认配置下,MySQL数据库允许非法的或不正确数据的插入或更新,如向not null的字段插入一个null,
会被更改为0再进行插入,修改参数<code class="inline-code">sql_mode</code>可以修改</p>
<pre><code class="language-mysql" data-comment="">set sql_mode='strict_trans_tables';</code></pre>
<h3>4.6.5 enum和set约束</h3>
<pre><code class="language-mysql" data-comment="">create table a (
    id int,,
    sex enum('male', 'female')
);
insert into a select 1, 'female';
insert into a select 2, 'bi';</code></pre>
<h3>4.6.6 触发器与约束</h3>
<p>触发器的作用是在执行insert、delete和update命令之前或之后自动调用sql命令或存储过程。</p>
<p>最多可以为一个表建立6个触发器,分别为insert、update、delete的before和after各定义一个。</p>
<pre><code class="language-mysql" data-comment="">create table usercach (
    userid int not null,
    cash int unsigned not null
);
insert into usercash select 1, 10000;
update usercash set cash=cash-(-20) where userid=1;
create table usercash_err_log (
    userid int not null,
    old_cash int unsigned not null,
    new_cash int unsigned not null,
    user varchar(30),
    time datetime
);
delimter $$
create trigger tgr_usercash_update before update on usercash for each row
begin
if new.cash-old.cash&gt;0 then
    insert into usercash_err_log select old.userid, old.cash, new.cash, USER(), NOW();
    set new.cash = old.cash;
end if;
end;
$$
delimiter $$</code></pre>
<h3>4.6.7 外键约束</h3>
<p>一般来说,称被引用的表为父表,引用的表为子表。</p>
<p>对子表所做的操作有:</p>
<ul>
<li>cascade 当父表发生delete或update时,对应子表数据页景象delete或update</li>
<li>set null 父表发送delete或update时,子表更新为null,子表对应列必须运行为null</li>
<li>no action 父表发生delete或update时,抛出错误</li>
<li>restrict 父表发生delete或update时,抛出错误</li>
</ul>
<p>InnoDB在外键建立时,自动地对该列加一个索引</p>
<p>外键会导致在数据到导入操作上花费大量时间。</p>
<h2>4.7 视图</h2>
<p>与持久表不同,视图中的数据没有实际的物理存储</p>
<h3>4.7.1 视图的作用</h3>
<p>被用作一个抽象装置,起到安全层的作用。</p>
<pre><code class="language-mysql" data-comment="">create table t(id int);
create view v_t as select * from t where id &lt; 10;
insert into v_t select 20;
select * from v_t;
alter view v_t as select * from t where id &lt; 10 with check option;
show tables;
-- 查看基表
select * from from information_schema.tables where table_type='base table'
and table_schema=database();
-- 查看视图元数据
select * from information_schema.views where table_schema=database();</code></pre>
<h3>4.7.2 物化视图</h3>
<p>物化视图可以用于预先计算并保存多表的链接或聚集等耗时较多的sql操作结果。对于一些复杂的统计
类查询能直接查出结果。</p>
<p>oracle物化视图的创建方式</p>
<ul>
<li>build immediate 在创建物化视图的时候生成数据</li>
<li>build deferred 在物化视图时不生成数据,以后根据需要生成数据</li>
</ul>
<p>物化视图的刷新指基表发生dml操作后,物化视图以何种方式和基表进行同步</p>
<ul>
<li>on demand 物化视图在用户需要的事实进行刷新</li>
<li>on commit 在基表的dml操作提交后同时进行刷新</li>
</ul>
<p>刷新的方法:</p>
<ul>
<li>fast 增量刷新,只刷新上次刷新以后进行的更改</li>
<li>complete 对整个物化视图进行完全的刷新</li>
<li>force 数据库在刷新时判断是否进行快速刷新,可以则用fast,否则用complete</li>
<li>never 不进行刷新</li>
</ul>
<p>mysql不支持物化视图</p>
<p>通过触发器,mysql可以实现类似物化视图的功能。</p>
<h2>4.8 分区表</h2>
<h3>4.8.1 分区概述</h3>
<p>分区功能不是存储引擎层完成的。</p>
<p>分区的过程是将一个表或索引分解为多个更小、更可管理的部分。</p>
<p>MySQL数据库支持的分区类型为水平分区,并不支持垂直分区。支持局部分区索引,不支持全局分区。</p>
<p><code class="inline-code">水平分区</code>:同一张表不同行的记录分配到不同物理文件中</p>
<p><code class="inline-code">垂直分区</code>:同一张表不同列的记录分配到不同物理文件中</p>
<p><code class="inline-code">局部分区</code>:一个分区中既存放数据有存放索引</p>
<p><code class="inline-code">全局分区</code>:数据存放在各个分区中,所有数据的索引放在一个对象中</p>
<pre><code class="language-mysql" data-comment="">show variables like '%partition%';</code></pre>
<p>分区主要用于数据库高可用性的管理</p>
<p>当前MySQL数据库支持以下几种类型的分区</p>
<ul>
<li>RANGE分区 行数据基于属于一个给定连续区间的列值被放入分区。</li>
<li>LIST分区 和RANGE分区类似,只是LIST分区面向的是离散的值</li>
<li>HASH分区 根据用户自定义的表达式的返回值来进行分区,返回值不能为负数</li>
<li>KEY分区 根据MySQL数据库提供的哈希函数来进行分区</li>
</ul>
<pre><code class="language-mysql" data-comment="">create table t1 (
    col1 int null,
    col2 date null,
    col3 int null,
    col4 int null,
    unique key (col1, col2, col3, col4)
)
partition by hash(col3)
partitions 4;</code></pre>
<h3>4.8.2 分区类型</h3>
<ol>
<li>RANGE分区</li>
</ol>
<pre><code class="language-mysql" data-comment="">create table t (id int) engine=inndb
partition by range(id) (
    partition p0 values less than (10),
    partition p1 values less than (20)
);</code></pre>
<pre><code class="language-mysql" data-comment="">select * from information_schema.partitions where table_schema=database()
and table_name='t';</code></pre>
<pre><code class="language-mysql" data-comment="">alter table t add partition(partition p2 values less than maxvalue);</code></pre>
<p>RANGE分区主要用户日期列的分区</p>
<pre><code class="language-mysql" data-comment="">-- 删除方便
alter table sales drop partition p2008;
-- 加快某些查询
explain partitions select * from sales where date&gt;='2008-01-01' and date&lt;='2018-12-31';</code></pre>
<ol start="2">
<li>LIST分区</li>
</ol>
<pre><code class="language-mysql" data-comment="">create table t (
    a int,
    b int
) engine=innodb
partition by list(b) (
    partition p0 values in (1, 3, 5, 7, 9),
    partition p1 values in (0, 2, 4, 6, 8)
);</code></pre>
<ol start="3">
<li>HASH分区</li>
</ol>
<p>HASH分区的目的是将数据均匀的分布到预先定义的各个分区中,保证各分区的数据数量大致都是一样的。</p>
<pre><code class="language-mysql" data-comment="">create table t (
    a int,
    b datetime
) engine=innodb
partition by hash(year(b))
partitions 4;</code></pre>
<p>MySQL还支持LINEAR HASH分区,</p>
<pre><code class="language-mysql" data-comment="">create table t (
    a int,
    b datetime
) engine=innodb
partition by linear hash(year(b)
partitions 4;</code></pre>
<ul>
<li>取大于分区数量4的下一个2的幂值，V=POWER(2,CEILING(LOG(2,num)))=4</li>
<li>所在分区N=YEAR('2010-04-01')&amp;(V-1)=2</li>
</ul>
<p>LINEAR HASH分区的优点:增加、删除、合并和拆分分区变得快捷,有利于处理含有大量数据的表,缺点:
与使用HASH分区得到的数据分布相比,各个分区键的数据分布可能不太均衡。</p>
<ol start="4">
<li>KEY分区</li>
</ol>
<pre><code class="language-mysql" data-comment="">create table t(
    a int,
    b datetime
) engine=innodb
partition by key(b)
partitions 4;</code></pre>
<ol start="5">
<li>COLUMNS分区</li>
</ol>
<p>COLUMNS分区可直接对非整型数据进行分区,分区根据类型比较而得,不需要转化成整型。</p>
<p>COLUMNS支持类型:</p>
<ul>
<li>所有的整型数据</li>
<li>日期类型</li>
<li>字符串类型</li>
</ul>
<h3>4.8.3 子分区</h3>
<p>子分区是在分区的基础上再进行分区,有时也称这种分区为复合分区。</p>
<pre><code class="language-mysql" data-comment="">create tablet(
    a int,
    b date
)engine=innodb
partition by range(year(b))
subpartition by hash(to_days(b))
subpartitions 2 (
    partition p0 values less than(1990),
    partition p1 values less than(2000),
    partition p2 values less than maxvalue
);</code></pre>
<p>子分区建立需要注意的问题</p>
<ul>
<li>每个子分区的数量必须相同</li>
<li>要在一个分区表的任何分区上使用subpartition来明确定义任何子分区,就必须定义所有的子分区。</li>
<li>每个subpartition子句必须包括子分区的一个名字</li>
<li>子分区的名字必须是唯一的</li>
</ul>
<h3>4.8.4 分区中的null值</h3>
<p>MySQL运行对null做分区,总是视nul小于任意一个非null值</p>
<p>对于RANGE分区,如果向分区插入null,则会将该值放在最左边的分区中。</p>
<p>在LIST分区使用NULL,必须显示指出哪个分区放入null值</p>
<p>HASH和KEY分区中,任何分区函数都会将含有null值的记录返回0</p>
<h3>4.8.5 分区和性能</h3>
<p>对于OLAP(在线分析处理),分区可以提高查询性能</p>
<p>对于OLTP(在线事务处理),B+树可以很好的完成操作,不需要分区的帮助</p>
<h3>4.8.6 在表和分区间交换数据</h3>
<p><code class="inline-code">alter table ... exchange partition</code>允许分区或子分区的数据与另外一个非分区中的表
中的数据进行交换。</p>
<p>但是需要满足以下条件:</p>
<ul>
<li>要交换的表和分区表有相同的表结构,但是表不能有分区</li>
<li>在非分区表中的数据必须在交换的分区定义内</li>
<li>被交换的表中不能含有外键,或者其他表含有对该表的外键引用</li>
<li>用户除了需要alter、insert和create权限外,还需要drop权限</li>
</ul>
<p>使用该语句时,不会触发交换表和被交换表的触发器,auto_increment列将被重置</p>
<h2>4.9 小结</h2>
<h6>2018.03.04</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>