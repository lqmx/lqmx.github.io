<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520866171">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第七章 事务</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520866171">
    <link rel="stylesheet" href="../../css/reset.css?v1520866171">
    <link rel="stylesheet" href="../../css/md.css?v1520866171">
    <link rel="stylesheet" href="../../css/module.css?v1520866171">
    <link rel="stylesheet" href="../../css/c.css?v1520866171">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520866171">
    <script src="../../dep/require.js?1520866171"></script>
</head>
<body>
    <div class="md"><h1>第七章 事务</h1>
<h6>2018.03.07</h6>
<p>事务会把数据库从一种一致性状态转换为另外一种一致状态。在数据库提交时,可以确保要么所有修改
都已经被保存,要么所有修改都不保存。</p>
<p>InnoDB事务完全符合ACID</p>
<ul>
<li>A 原子性 atomicity</li>
<li>C 一致性 consistency</li>
<li>I 隔离性 isolation</li>
<li>D 持久性 durability</li>
</ul>
<h2>7.1 认识事务</h2>
<h3>7.1.1 概述</h3>
<ul>
<li>A(Atomicity) 原子性</li>
</ul>
<p>原子性指整个数据库事务是不可分割的工作单位。要么全做,要么都不做。</p>
<ul>
<li>C(Consistency) 一致性</li>
</ul>
<p>一致性是指事务将数据库从一种状态转变为下一种一致的状态。</p>
<ul>
<li>I(Isolation) 隔离性</li>
</ul>
<p>事务的隔离性要求每个读写事务中的对象对其他事务的操作对象能相互分离,即该事务提交前对其他事务
都不可见,通常这使用锁来实现。</p>
<ul>
<li>D(Durability) 持久性</li>
</ul>
<p>事务一旦提交,其结果就是永久的。</p>
<h3>7.1.2 分类</h3>
<p>从事务理论的角度来说,可以把事务分为以下几种类型:</p>
<ul>
<li>扁平事务</li>
<li>带有保存点的扁平事务</li>
<li>链事务</li>
<li>嵌套事务</li>
<li>分布式事务</li>
</ul>
<ol>
<li>扁平事务</li>
</ol>
<p>事务类型中最简单的一种。扁平事务中,所有操作都处于同一层次,要么多执行,要么都回滚。</p>
<p>扁平事务的主要限制是不能提交或者回滚事务中的某一部分,或分几个步骤提交。</p>
<ol start="2">
<li>带有保存点的扁平事务</li>
</ol>
<p>除了支持扁平事务支持的操作外,允许在事务执行过程中回滚到同一事务中较早的一个状态。</p>
<p>保存点用来通知系统应该记住事务当前的状态,以便当之后发生错误时,事务能回到保存点当时的状态。</p>
<ol start="3">
<li>链事务</li>
</ol>
<p>链事务可视为保存点模式的一种变种。带有保存点的扁平事务,当发生系统崩溃时,所有的保存点都将消失,因为其
保存点是易失的,而非持久的。这意味着当进行恢复时,事务需要从开始处重新执行,而不能从最近的一个保存点继续执行。</p>
<p>链事务的思想是:在提交一个事务时,释放不需要的数据对象,将必要的处理上下文隐式地传给下一个要开始的事务。</p>
<ol start="4">
<li>嵌套事务</li>
</ol>
<p>嵌套事务是一个层次结构框架。由一个顶层事务控制各个层次的事务。</p>
<ol start="5">
<li>分布式事务</li>
</ol>
<p>是一个在分布式环境下运行的扁平事务。</p>
<h2>7.2 事务的实现</h2>
<p>事务隔离性由锁来实现,原子性、一致性、持久性通过数据库的redo log和undo log来完成。
redo log为重做日志,用来保证事务的原子性和持久性。undo log用来保证事务的一致性。</p>
<p>redo恢复提交事务修改的页操作,undo回滚行记录到某个特定版本。redo通常是物理日志,记录的是
页的物理修改操作,undo是逻辑日志,根据每行记录进行记录。</p>
<h3>7.2.1 redo</h3>
<ol>
<li>基本概念</li>
</ol>
<p>重做日志用来实现事务的持久性,即事务ACID中的D。其由两部分组成:一是内存中的重做日志缓冲,
其是易失的;二是重做日志文件,其实持久的。</p>
<p>InnoDB通过Force Log at Commit机制实现事务的持久性,即事务提交时,必须先将该事务的所有
日志写入到重做日志文件进行持久化,待事务commit完成后才算完成。</p>
<p><code class="inline-code">innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略。</p>
<p>binlog和redo log的异同</p>
<p>同: 都是记录了对于数据库操作的日志</p>
<p>异:</p>
<ul>
<li>redo log是存储引擎层产生的,binlog是数据库上层产生的,并且binlog不仅仅针对于InnoDB,</li>
<li>binlog为逻辑日志,记录的为对应的SQL语句,redo log为物理格式日志,记录的是对页的修改</li>
<li>binlog只在事务提交完成后进行一次写入。redo log在事务进行中不断被写入,</li>
</ul>
<ol start="2">
<li>log block</li>
</ol>
<p>InnoDB中,重做日志是以512字节存储的,重做日志缓存、重做日志文件都是以块的形式进行保存的,
称之为重做日志块,每块大小512字节。</p>
<p>日志块由三个部分组成:日志块头、日志内容和日志块尾。</p>
<ol start="3">
<li>log group</li>
</ol>
<p>log group为重做日志组,其中有多个重做日志文件。log group是一个逻辑上的概念,并没有一个
实际存储的物理文件来表示log group信息。</p>
<p>InnoDB中,log buffer根据一定的规则将内存中的log block刷新到磁盘</p>
<p>具体规则为:</p>
<ul>
<li>事务提交时</li>
<li>当log buffer中有一半的内存空间已经被使用时</li>
<li>log checkpoint时</li>
</ul>
<h6>2018.03.12</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>