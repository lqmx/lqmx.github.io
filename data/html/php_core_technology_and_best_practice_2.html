<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1518445369">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PHP核心技术与最佳实践-第二章-面向对象的设计原则</title>
    <link rel="stylesheet" href="../../css/reset.css?v1518445369">
    <link rel="stylesheet" href="../../css/md.css?v1518445369">
    <link rel="stylesheet" href="../../css/module.css?v1518445369">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1518445369">
    <script src="../../dep/require.js?1518445369"></script>
</head>
<body>
<div class="md"><h1>2 面向对象的设计原则</h1>
<h6>20180210</h6>
<h2>2.1 面向对象设计的五大原则</h2>
<h3>2.1.1 单一职责原则(Single Pesponsibility Principle)</h3>
<blockquote class="bq4">
<p>就一个类而言,应该只有一个引起它变化的原因</p>
</blockquote>
<p>单一职责有两个含义:</p>
<ol>
<li>避免相同的职责分散到不同的类中</li>
<li>避免一个类承担太多职责</li>
</ol>
<p>为什么要遵守SRP</p>
<ol>
<li>可以减少类之间的耦合</li>
<li>提高类的复用性</li>
</ol>
<p>SRP的应用:</p>
<ol>
<li>工厂模式</li>
</ol>
<pre><code class="language-php" data-comment="">// srp-factory
interface Db_Adapter {
    public function connect($config);
    public function query($query, $handle);
}
class Db_Adapter_Mysql implements Db_Adapter {

    private $_dbLink;
    public function connect($config) {
        // ..
    }

    public function query($query, $handle) {
        // ..
    }
}
class Db_Adapter_SQLite implements Db_Adapter {

    private $_dbLink;

    public function connect($config) {
        // ..
    }

    public function query($query, $handle) {
        // ..
    }
}
class sqlFactory {
    public static function factory($type) {
        $cls_name = 'Db_Adapter_'.$type;
        return new $cls_name;
    }

}
$db = sqlFactory::factory('Mysql');
$db = sqlFactory::factory('SQLite');</code></pre>
<ol start="2">
<li>命令模式</li>
</ol>
<pre><code class="language-php" data-comment="">class Cook {
    public function meal () {
        echo 'meal', PHP_EOL;
    }

    public function drink() {
        echo 'drink', PHP_EOL;
    }

    public function ok () {
        echo 'ok', PHP_EOL;
    }
}
interface Command {
    public function execute(); 
}
class MealCommand implements Command {
    private $cook;
    public function __construct(Cook $cook) {
        $this-&gt;cook = $cook;
    }

    public function execute() {
        $this-&gt;cook-&gt;meal();
    }
}
class DrinkCommand implements Command {
    private $cook;
    public function __construct(Cook $cook) {
        $this-&gt;cook = $cook;
    }
    public function execute() {
        $this-&gt;cook-&gt;drink();
    }
}
class CookControl {
    private $mealcommand;
    private $drinkcommand;
    public function addCommand(Command $mealcommand, Command $drinkcommand) {
        $this-&gt;mealcommand = $mealcommand;
        $this-&gt;drinkcommand = $drinkcommand;
    }
    public function callmeal() {
        $this-&gt;mealcommand-&gt;execute();
    }
    public function calldrink() {
        $this-&gt;drinkcommand-&gt;execute();
    }
}
$control = new CookControl;
$cook = new Cook;
$mealcommand = new MealCommand($cook);
$drinkcommand = new DrinkCommand($cook);
$control-&gt;addCommand($mealcommand, $drinkcommand);
$control-&gt;callmeal();
$control-&gt;calldrink();</code></pre>
<ol start="3">
<li>代理模式</li>
</ol>
<h3>2.1.2 接口隔离原则(Interface Segregation Principle)</h3>
<blockquote class="bq4">
<p>客户端不应该被强迫实现一些他们不会使用的接口,应该把胖接口中的方法分组,然后用多个
接口代替它,每个接口服务于一个子模块</p>
</blockquote>
<p>ISP的观点如下:</p>
<ol>
<li>一个类对另外一个类的依赖性应当是建立在最小的接口上的</li>
<li>客户端程序不应该依赖它不需要的接口方法(功能)</li>
</ol>
<p>对于接口的污染,可以考虑下面两条处理方式:</p>
<ol>
<li>利用委托分离接口</li>
<li>利用多继承分离接口</li>
</ol>
<h3>2.1.3 开发-封闭原则(Open Close Principle)</h3>
<blockquote class="bq4">
<p>模块的行为必须是开放的、支持扩展的、而不是僵化的
在对模块的功能进行扩展时,不应该影响或大规模影响已有的程序模块
一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的</p>
</blockquote>
<pre><code class="language-php" data-comment="">interface process {
    public function process();
}
class playerencode implements process {
    public function process() {
        echo 'encode', PHP_EOL;
    }
}
class playeroutput implements process {
    public function process () {
        echo 'output', PHP_EOL;
    }
}
class playProcess {
    private $message = null;
    public function __construct() {
    }

    public function callback(event $event) {
        $this-&gt;message = $event-&gt;click();
        if($this-&gt;message instanceof process) {
            $this-&gt;message-&gt;process();
        }
    }
}
class mp4 {
    public function work() {
        $playProcess = new playProcess;
        $playProcess-&gt;callback(new event('encode'));
        $playProcess-&gt;callback(new event('output'));
    }

}
class event {
    private $m;
    public function __construct($me) {
        $this-&gt;m = $me;
    }
    public function click() {
        switch($this-&gt;m) {
        case 'encode':
            return new playerencode;
        case 'output':
            return new playeroutput;
        }
    }
}
$mp4 = new mp4();
$mp4-&gt;work();</code></pre>
<p>如何遵守开放-封闭原则
让类依赖于固定的抽象,这个的修改是封闭的
通过面向对象的继承和多态,可以实现对抽象体的继承,通过复写其方法来
改变固有行为,实现新的扩展方法,所以对扩展是开放的</p>
<ol>
<li>在设计方面充分利用&quot;抽象&quot;和&quot;封装&quot;的思想</li>
<li>在系统功能编程实现方面应用面向接口的编程</li>
</ol>
<p>应用:
装饰模式</p>
<h3>2.1.4 替换原则(Liskov Substitution Principle)</h3>
<blockquote class="bq4">
<p>子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方</p>
</blockquote>
<p>LSP主要是针对继承的设计原则</p>
<p>LSP要解决的问题</p>
<ol>
<li>如何正确地进行继承方面的设计</li>
<li>最佳的继承层次如何获得</li>
<li>怎样避免所设计的类层次陷入不符合OCP原则的状况</li>
</ol>
<p>如何遵守:</p>
<ol>
<li>父类的方法都要在子类中实现或者重写,并且派生类只实现其抽象类中声明的方法,
而不应该给出多余的方法定义或实现</li>
<li>在客户端程序中只应该使用父类对象而不应该直接使用子类对象,这样可以实现
运行期绑定(多态)</li>
</ol>
<pre><code class="language-php" data-comment="">abstract class Cache {
    public abstract function set($key, $value, $expire = 60);
    public abstract function get($key);
    public abstract function del($key);
    public abstract function delAll();
    public abstract function has($key);
}</code></pre>
<h3>2.1.5 依赖倒置原则(Dependence Inversion Principle)</h3>
<blockquote class="bq4">
<p>上层模块不应该依赖下层模块,它们共同依赖一个抽象</p>
</blockquote>
<pre><code class="language-php" data-comment="">interface employee {
    public function working();
}

class teacher implements employee {
    public function working() {
        echo 'teaching', PHP_EOL;
    }
}
class coder implements employee {
    public function working() {
        echo 'codeing', PHP_EOL;
    }
}
class workA {
    public function work() {
        $teacher = new teacher;
        $teacher-&gt;working();
    }
}
class workB {
    private $e;
    public function set(employee $e) {
        $this-&gt;e = $e;
    }

    public function work(){
        $this-&gt;e-&gt;working();
    }
}
$worka = new workA;
$worka-&gt;work();
$workb = new workB;
$workb-&gt;set(new teacher());
$workb-&gt;work();</code></pre>
<p>如何满足DIP:</p>
<ol>
<li>每个较高层次类都为它所需要的服务提出一个接口声明,较低层次类实现这个接口</li>
<li>每个高层类都通过该抽象接口使用服务</li>
</ol>
<h2>2.2 一个面向对象留言本的实例</h2>
<p>用户填写信息-&gt;留言-&gt;展示</p>
<pre><code class="language-php" data-comment="">// message.php
class message {
    public $name;
    public $email;
    public $content;
    public function set($name, $value) {
        $this-&gt;$name = $value;
    }

    public function get($name) {
        if(!isset($this-&gt;$name)) {
            $this-&gt;$name = NULL;
        }
        return $this-&gt;$name;
    }
}
// gbookModel.php
class gbookModel {
    private $bookPath;
    private $data;

    public function setBookPath($bookPath) {
        $this-&gt;bookPath = $bookPath;
    }

    public function open() {
    }

    public function close() {
    }

    public function read() {
        return file_get_contents($this-&gt;bookPath);
    }

    public function write($data) {
        $this-&gt;data = self::safe($data)-&gt;name."&amp;".self::safe($data)-&gt;email."\r\nsaid: \r\n".self::safe($data)-&gt;content;
        return file_put_contents($this-&gt;bookPath, $this-&gt;data, FILE_APPEND);
    }

    public static function safe($data) {
        $reflect = new RelectionObject($data);
        $props = $reflect-&gt;getProperties();
        $messagebox = new stdClass();
        foreach($props as $prop) {
            $ivar = $prop-&gt;getName();
            $messagebox-&gt;$ivar = trim($prop-&gt;getValue($data));
        }
        return $messagebox;
    }

    public function delete() {
        file_put_contents($this-&gt;bookPath, "it's empty now");
    }

    public function readByPage() {
        $handle = file($this-&gt;bookPath);
        $count = count($handle);
        $page = isset($_GET['page'])?intval($_GET['page']):1;
        if($page &lt; 1 || $page &gt; $count) $page = 1;
        $pnum = 9;
        $begin = ($page-1)*$pnum;
        $end = ($begin + $pnum) &gt; $count ? $count : $begin + $pnum;
        for($i = $begin; $i &lt; $end; $i ++ ) {
            echo '&lt;strong&gt;', $i + 1, '&lt;/strong&gt;', $handle[$i], '&lt;br/&gt;';
        }
        for($i = 1; $i &lt; ceil($count/$pnum); $i++) {
            echo "&lt;a href=? page=${i} &gt;${i}&lt;/a&gt;";
        }
    }

}
// leaveModel.php
class leaveModel {
    public function write(gbookModel $gb, $data) {
        $book = $gb-&gt;getBookPath();
        $gb-&gt;write($data);
    }

}
// authorControl.php
class authorControl {
    public function message(leaveModel $l, gbookModel $g, message $data) {
        $l-&gt;write($g, $data);
    }

    public function view(gbookModel $g) {
        return $g-&gt;read();
    }

    public function delete(gbookModel $g) {
        $g-&gt;delete();
        echo self::view($g);
    }

    public function viewByPage(gbookModel $g) {
        return $g-&gt;readByPage();
    }
}

$message = new message;
$message-&gt;name = 'phper';
$message-&gt;email = 'phper@php.net';
$message-&gt;content = 'a crezy phper love php so much.';
$gb = new authorControl;
$pen = new leaveModel;
$book = new gbookModel;
$book-&gt;setBookPath("./message.txt");
$gb-&gt;message($pen, $book, $message);
echo $gb-&gt;view($book);
$gb-&gt;delete($book);</code></pre>
<h2>2.3 面向对象的思考</h2>
<p>对于流程明确、需求清晰、需求变更风险小的业务逻辑,过程化开发最合适,反之,抽象思维是最
合适的,用面向对象的思维去抽象业务模型并随需求不断精化,最终交付使用,其扩展度和可维护性
都要比过程化方法更好。</p>
<h2>2.4 本章小结</h2>
<p>面向对象的五大原则</p>
<h6>20180211</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>