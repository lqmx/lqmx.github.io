<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1521381589">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>算法之美 排序</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1521381589">
    <link rel="stylesheet" href="../../css/reset.css?v1521381589">
    <link rel="stylesheet" href="../../css/md.css?v1521381589">
    <link rel="stylesheet" href="../../css/module.css?v1521381589">
    <link rel="stylesheet" href="../../css/c.css?v1521381589">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1521381589">
    <script src="../../dep/require.js?1521381589"></script>
</head>
<body>
    <div class="md"><h1>第十一章 排序</h1>
<h6>2018.03.17</h6>
<h2>11.1 排序问题概述</h2>
<h3>11.1.1 基本概念和定义</h3>
<ol>
<li>数据表</li>
</ol>
<p>待排序的有限数据集</p>
<ol start="2">
<li>关键码</li>
</ol>
<p>数据对象中起标识作用的数据项</p>
<ol start="3">
<li>排序的数学定义</li>
</ol>
<p>按照一定的算法把数据对象一次排列起来,使一组按关键码任意排列的对象变成按关键码线性有序排列的对象。</p>
<h3>11.1.2 排序算法的分类</h3>
<ol>
<li>稳定排序和非稳定排序</li>
</ol>
<p>排序后两个多个关键码相同的对象具有与排序前相同的顺序,就称相应的排序方法是稳定的,否则就是不稳定的。</p>
<ol start="2">
<li>内排序与外排序</li>
</ol>
<p>待排序记录存放在计算机随机存储器中进行的排序过程称为内排序,否则为外排序。</p>
<h3>11.1.3 排序算法的分析</h3>
<p>通常,估算算法运行的时间代价可以按平均情况来进行,特别地,那些受对象关键码初始状态和对象个数影响
较大的情况,需要按最好情况和最坏情况进行估算。</p>
<p>算法执行时所需的附加空间也是一个考察排序算法性能的指标。</p>
<p>当数据量不大时选择插入排序或选择排序,不要用冒泡排序。
当数据量大而且注重空间复杂性时选择快速排序或堆排序。
当数据量大又运行使用较多的附加空间时选择桶排序。
当要在已排序数据上增加若干新数据时选择插入排序。</p>
<h2>11.2 插入排序</h2>
<blockquote class="bq3">
<p>每次将一个带排序数据对象按关键码大小插入一个有序的数据序列中,得到一个新的容量加1的数据序列,
如此往复直到全部对象插入完毕为止</p>
</blockquote>
<h3>11.2.1 直接插入排序</h3>
<p>时间效率为O(n^2)</p>
<pre><code class="language-php" data-comment="">function insertSort($data) {
        for($i = 1; $i &lt; count($data); $i ++) {
            $insertNum = $data[$i];
            $j = $i;
            while($j &gt; 0 and $insertNum &lt; $data[$j-1]) {
                $data[$j] = $data[$j-1];
                $j --;
            }
            $data[$j] = $insertNum;
        }
        return $data;
    }</code></pre>
<h3>11.2.2 二分插入排序</h3>
<pre><code class="language-php" data-comment="">function binaryInsertSort($data) {
        for($i = 0; $i &lt; count($data); $i ++) {
            $insertNum = $data[$i];
            $left = 0;
            $right = $i -1;
            while ($left &lt;= $right) {
                $middle = intval(($left+$right)/2);
                if($insertNum &gt; $data[$middle]) $left = $middle + 1;
                else $right = $middle - 1;
            }
            for($j = $i; $j &gt; $left; $j--) $data[$j] = $data[$j-1];
            $data[$left] = $insertNum;
        }
        return $data;
    }</code></pre>
<h3>11.2.3 希尔排序</h3>
<pre><code class="language-php" data-comment="">function shellSort($data) {
        $len = count($data);
        $gap = intval($len/2);
        while ($gap) {
            for($i = $gap; $i &lt; $len; $i ++) {
                $insertNum = $data[$i];
                $j = $i;
                while ($j &gt;= $gap &amp;&amp; $insertNum &lt; $data[$j-$gap]) {
                    $data[$j] = $data[$j-$gap];
                    $j -= $gap;
                }
                $data[$j] = $insertNum;
            }
            $gap = intval($gap/2);
        }
        return $data;
    }</code></pre>
<h2>11.3 选择排序</h2>
<blockquote class="bq3">
<p>在排序时每次选择最小项或最大项,将其放入适当位置,以此类推。</p>
</blockquote>
<h3>11.3.1 直接选择排序</h3>
<pre><code class="language-php" data-comment="">function selectSort($data) {
        $len = count($data);
        for($i = 0; $i &lt; $len; $i ++) {
            $k = $i;
            for($j = $i + 1; $j &lt; $len; $j ++) {
                if($data[$j] &lt; $data[$k]) $k = $j;
            }
            swap($data, $i, $k);
        }
        return $data;
    }</code></pre>
<h3>11.3.2 堆排序</h3>
<ol>
<li>将无序序列构成一个堆</li>
<li>将堆顶元素与末尾元素交换</li>
<li>调整结构,使其满足堆的定义</li>
<li>重复上面步骤</li>
</ol>
<pre><code class="language-php" data-comment="">function filterDown(&amp;$data, $current, $last) {
        while (($left = 2 * $current + 1) &lt;= $last) {
            $right = $left + 1;
            $j = $left;
            if($j &lt; $last &amp;&amp; $data[$left] &lt; $data[$right]) $j ++;

            if($data[$current] &lt; $data[$j]) {
                swap($data, $current, $j);
            } else {
                break;
            }
            $current = $j;
        }
    }
function heapSort($data) {
        $len = count($data);
        for($i = intval(($len-2)/2); $i &gt;=0; $i --)
            filterDown($data, $i, $len-1);

        for($i = $len-1; $i &gt; 0; $i --) {
            swap($data, 0, $i);
            filterDown($data, 0, $i-1);
        }
        return $data;
    }</code></pre>
<h2>11.4 交换排序</h2>
<blockquote class="bq3">
<p>两两比较待排序对象的关键码,如果发生逆序就交换,知道所有对象都排序完毕</p>
</blockquote>
<h3>11.4.1 冒泡排序</h3>
<pre><code class="language-php" data-comment="">function bubbleSort($data) {
        $len = count($data);
        for($i = 0; $i &lt; $len; $i++) {
            for($j = $i + 1; $j &lt; $len; $j ++) {
                if($data[$i] &gt; $data[$j]) swap($data, $i, $j);
            }
        }
        return $data;
    }</code></pre>
<h3>11.4.2 鸡尾酒排序</h3>
<pre><code class="language-php" data-comment="">function shakerSort($data) {
        $len = count($data);
        $left = 0;
        $right = $len - 1;
        $shift = 0;
        while ($left &lt; $right) {
            for($i = $left; $i &lt; $right; $i ++ ) {
                if($data[$i] &gt; $data[$i+1]) {
                    swap($data, $i, $i + 1);
                    $shift = $i;
                }
            }
            $right = $shift;
            for($i = $right; $i &gt; $left; $i --) {
                if($data[$i] &lt; $data[$i-1]) {
                    swap($data, $i, $i - 1);
                    $shift = $i;
                }
            }
            $left = $i;
        }
        return $data;
    }</code></pre>
<h3>11.4.3 快速排序</h3>
<pre><code class="language-php" data-comment="">function quickSort($data) {

        $len = count($data);
        if($len &lt;= 1) return $data;

        $left = $right = array();
        $base = $data[0];
        for($i = 1; $i &lt; $len; $i ++) {
            if($data[$i] &lt; $base) {
                $left[] = $data[$i];
            }else {
                $right[] = $data[$i];
            }
        }
        $left = self::quickSort($left);
        $right = self::quickSort($right);
        return array_merge($left, array($base), $right);
    }</code></pre>
<h3>11.5 归并排序</h3>
<pre><code class="language-php" data-comment="">function merge($arrA,$arrB)
{
        $arrC = array();
        while(count($arrA) &amp;&amp; count($arrB)){
            $arrC[] = $arrA[0] &lt; $arrB[0] ? array_shift($arrA) : array_shift($arrB);
        }
        return array_merge($arrC, $arrA, $arrB);
    }
function mergeSort($data){
        $len=count($data);
        if($len &lt;= 1)
            return $data;
        $mid = intval($len/2); 
        $left = array_slice($data, 0, $mid); 
        $right = array_slice($data, $mid);
        $left = mergeSort($left); 
        $right = mergeSort($right); 
        $arr= merge($left, $right); 
        return $arr;
    }</code></pre>
<h3>11.6 计数排序</h3>
<h6>2018.03.18</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>