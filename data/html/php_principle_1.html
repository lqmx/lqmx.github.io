<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1521982189">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PHP底层的运行机制与原理</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1521982189">
    <link rel="stylesheet" href="../../css/reset.css?v1521982189">
    <link rel="stylesheet" href="../../css/md.css?v1521982189">
    <link rel="stylesheet" href="../../css/module.css?v1521982189">
    <link rel="stylesheet" href="../../css/c.css?v1521982189">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1521982189">
    <script src="../../dep/require.js?1521982189"></script>
</head>
<body>
    <div class="md"><h1>PHP底层的运行机制与原理</h1>
<h6>2018.03.25</h6>
<h2>PHP的设计理念及特点</h2>
<ul>
<li>多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响。当然，随着时代发展，PHP也早已支持多线程模型。</li>
<li>弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效，具体会在后面PHP变量中详述。</li>
<li>引擎(Zend)+组件(ext)的模式降低内部耦合。</li>
<li>中间层(sapi)隔绝web server和PHP。</li>
<li>语法简单灵活，没有太多规范。缺点导致风格混杂，但再差的程序员也不会写出太离谱危害全局的程序。</li>
</ul>
<h2>PHP的四层体系</h2>
<p>PHP从下到上是一个4层体系</p>
<ul>
<li>Zend引擎：Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode处理，并实现相应的处理方法，实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。</li>
<li>Extensions：围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）。</li>
<li>Sapi：Sapi全称是Server Application Programming Interface，也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。</li>
<li>Application：这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等。</li>
</ul>
<h2>Sapi</h2>
<ul>
<li>apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式。</li>
<li>cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。</li>
<li>cli：命令行调用的应用模式</li>
</ul>
<h2>PHP的执行流程&amp;opcode</h2>
<ol>
<li>Scanning(Lexing),将PHP代码转换为语言片段(Tokens)</li>
<li>Parsing,将Tokens转换为简单而有意义的表达式</li>
<li>Compilation,将表达式编译成Opcode</li>
<li>Execution,顺次执行Opcodes,从而实现PHP脚本的功能</li>
</ol>
<p>拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令(opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作</p>
<h2>HashTable — 核心数据结构</h2>
<p>PHP的hash table具有如下特点：</p>
<ul>
<li>支持典型的key-&gt;value查询</li>
<li>可以当做数组使用</li>
<li>添加、删除节点是 O(1) 复杂度</li>
<li>key支持混合类型：同时存在关联数组和索引数组</li>
<li>Value支持混合类型：array (&quot;string&quot;, 2332)</li>
<li>支持线性遍历：如foreach</li>
</ul>
<p>在hash table中既有key-&gt;value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。</p>
<ul>
<li>散列结构：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行key-&gt;value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量nKeyLength标识key的长度以作快速判定。</li>
<li>双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。</li>
<li>PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程，并增加一些快速判定加速查找。）：
<pre><code class="language-c" data-comment="">getKeyHashValue h;
index = n &amp; nTableMask;
Bucket *p = arBucket[index];
while (p) {
if ((p-&gt;h == h) &amp; (p-&gt;nKeyLength == nKeyLength)) {
    RETURN p-&gt;data;   
}
p=p-&gt;next;
}
RETURN FALTURE;</code></pre></li>
<li>PHP索引数组：索引数组就是我们常见的数组，通过下标访问。例如 $arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 $arr[1] = 2; $arr[2] = 3; 对于double类型的key，Zend HashTable会将他当做索引key处理</li>
</ul>
<h2>PHP变量</h2>
<p>所有的变量在底层都是同一种结构 zval。</p>
<pre><code class="language-c" data-comment="">typedef union _zvalue_value {
    long lval;
    double dval;
    struct {
        char *val;
        int len;
    } str;
    HashTable *ht;
    zend_object_value obj;
} zvalue_value;

strucct _zval_struct {
    zvalue_value value;
    zend_unit refcount;
    zend_uchar type;
    zend_uchar is_ref;
};

typedef struct _zval_struct zval;</code></pre>
<p>Zval主要由三部分组成：</p>
<ul>
<li>type：指定了变量所述的类型（整数、字符串、数组等）</li>
<li>refcount&amp;is_ref：用来实现引用计数(后面具体介绍)</li>
<li>value：核心部分，存储了变量的实际数据</li>
</ul>
<h3>引用计数</h3>
<p>引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。</p>
<p>在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。</p>
<p>PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝)</p>
<h3>整数和浮点数</h3>
<p>整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。</p>
<p>在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型</p>
<h3>字符和字符串</h3>
<p>和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中，求字符串长度strlen是O(1)操作。</p>
<p>在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加\0。</p>
<p>现在对如下的几种字符串拼接方式做一个比较和说明：</p>
<pre><code class="language-php" data-comment="">// 下面两张情况，zend会重新malloc一块内存并进行相应处理，其速度一般
$res = $strA . $strB
$res = "$strA$strB"

// 这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝
$strA = $strA . $strB

// 这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免
$res = $intA . $intB

// 这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，
// 本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。
// 不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。
$strA = sprintf ("%s%s", $strA . $strB);</code></pre>
<h3>数组</h3>
<p>PHP的数组通过Zend HashTable来天然实现。</p>
<p>foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用HashTable-&gt;NumOfElements，O(1)操作。对于 '123' 这样的字符串，zend会转换为其整数形式。<code class="inline-code">$arr['123']</code>和<code class="inline-code">$arr[123]</code>是等价的。</p>
<h3>资源</h3>
<p>资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。</p>
<p>PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。</p>
<p>在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。</p>
<p>如何使用资源：</p>
<ul>
<li>注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。</li>
<li>获取一个资源变量：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。</li>
<li>资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。</li>
</ul>
<p>资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分。</p>
<h3>变量作用域</h3>
<p>PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。</p>
<ul>
<li>
<p>获取变量值：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。</p>
</li>
<li>函数中使用全局变量：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用，如果symbol_table中没有同名变量则会先创建。</li>
</ul>
<h2>参考</h2>
<ul>
<li><a href="https://www.awaimai.com/509.html">PHP底层的运行机制与原理</a></li>
</ul>
<h6>2018.03.25</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>