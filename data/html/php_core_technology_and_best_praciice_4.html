<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1519133635">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PHP核心技术与最佳实践-第四章-PHP网络技术及应用</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1519133635">
    <link rel="stylesheet" href="../../css/reset.css?v1519133635">
    <link rel="stylesheet" href="../../css/md.css?v1519133635">
    <link rel="stylesheet" href="../../css/module.css?v1519133635">
    <link rel="stylesheet" href="../../css/c.css?v1519133635">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1519133635">
    <script src="../../dep/require.js?1519133635"></script>
</head>
<body>
    <div class="md"><h1>第四章 PHP网络技术及应用</h1>
<h2>4.1 HTTP协议详解</h2>
<p>HTTP是一个基于应用层的通信规范</p>
<h3>4.1.1 HTTP协议与SPDY协议</h3>
<p>HTTP是一个应用层协议,由请求和响应构成,是一个标准的客户端服务器模型。</p>
<p>HTTP协议是一个无状态的协议,同一个客户端的两个请求没有对应关系。</p>
<p>SPDY协议是Google推出的协议,优化了浏览器和服务器之间的通信</p>
<ul>
<li>支持流复用</li>
<li>具备优先级的请求</li>
<li>主动发起请求</li>
<li>强制SSL安全传输</li>
</ul>
<p>SPDY协议的应用需要客户端和服务器同时支持</p>
<h3>4.1.2 HTTP协议如何工作</h3>
<p>一次HTTP操作称为一个事务</p>
<ol>
<li>客户端与服务器建立连接</li>
<li>客户端发送一个请求给服务器(URL+协议版本号+MIME信息)</li>
<li>服务器接到请求,给予响应(状态行+MIME信息)</li>
<li>客户端与服务器断开连接</li>
</ol>
<p>协议中的一些概念</p>
<ol>
<li>请求</li>
</ol>
<p>HTTP请求由三个部分组成:<code class="inline-code">请求行</code>,<code class="inline-code">消息报头</code>,<code class="inline-code">请求正文</code></p>
<p>请求行: Method(请求方法) Request-URL(统一资源标识符) HTTP-Version(HTTP协议版本) CRLF(回车和换行)</p>
<p>请求方法如下:</p>
<ul>
<li>GET 请求获取Request URL所标识的资源</li>
<li>POST 在Request URL所标识的资源后面附加新的数据</li>
<li>HEAD 请求获取由Request URL所标识的资源的响应消息报头</li>
<li>PUT 请求服务器存储一个资源,并用Request URL作为其标识</li>
<li>DELETE 请求服务器删除Request URL所标识的资源</li>
<li>TRACE 请求服务器回送收到的请求消息,主要用于测试或诊断</li>
<li>CONNECT 保留以备将来使用</li>
<li>OPTIONS 请求查询服务器的性能,或者查询与资源相关的选项和需求</li>
</ul>
<ol start="2">
<li>响应</li>
</ol>
<p>HTTP响应也由三个部分组成:<code class="inline-code">状态行</code>,<code class="inline-code">消息报头</code>,<code class="inline-code">响应正文</code></p>
<p>状态行: HTTP-Version(HTTP协议版本) Status-Code(服务器返回的响应状态代码) Reason-Phrase(状态代码的文本描述) CRLF(回车和换行)</p>
<p>状态代码:</p>
<ul>
<li>1xx: 指示消息-请求已接收,继续处理</li>
<li>2xx: 成功-请求已被成功接收、理解、接受</li>
<li>3xx: 重定向-要完成请求必须进一步的操作</li>
<li>4xx: 客户端错误-请求有语法错误或请求无法实现</li>
<li>5xx: 服务端错误-服务端未能实现合法的请求</li>
</ul>
<p>常见的状态码:</p>
<ul>
<li>200 OK 客户端请求成功</li>
<li>400 Bad Request 客户端请求有语法错误,不能被服务端理解</li>
<li>401 Unauthorized 请求未经授权</li>
<li>403 Forbidden 服务器收到请求,但是拒绝提供服务</li>
<li>404 Not Found 请求资源不存在</li>
<li>500 Internal Server Error 服务器发生不可预期的错误</li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求,一段时间后可能恢复正常</li>
</ul>
<ol start="3">
<li>报头</li>
</ol>
<p>HTTP消息报头包括<code class="inline-code">普通报头</code>,<code class="inline-code">请求报头</code>,<code class="inline-code">响应报头</code>,<code class="inline-code">实体报头</code></p>
<p>报头的格式: 名字+: +空格+值</p>
<p>消息报头域的名字不区分英文大小写</p>
<ul>
<li>普通报头中有少数报头域用户所有的请求和响应消息,但不用于被传输的实体,只用于传输的消息
(如缓存控制、连接控制等)</li>
<li>请求报头允许客户端向服务器传递请求的附加消息以及客户端自身的信息(如UA头、Accept等)</li>
<li>响应报头允许服务器传递不能放在状态行中的附加响应信息,以及关于服务器的消息和对Request
URL所标志的资源进行下一步的访问的消息(如Location)</li>
<li>实体报头定义了关于实体正文和请求所标志的资源的元信息,例如有无实体正文</li>
</ul>
<p>比较重要的报头:</p>
<ul>
<li>Host 头域指定请求资源的Internet主机和端口号</li>
<li>User Agent 包含发出请求的用户信息(不仅使用浏览器才存在,只要使用了基于HTTP协议的客户端
软件都会发送这个请求)</li>
<li>Cookie 
<ul>
<li>客户端向服务端发送的,使用Cookie报头(value里可以有多个Cookie值,不需要显式指定domain等)</li>
<li>服务端发送给浏览器的,报头为Set Cookie(只能有一个Cookie的value,需要指定domain、path等)</li>
</ul></li>
<li>Cache Control 指定请求和响应遵循的缓存机制</li>
<li>Referer 头域允许客户端指定请求URI的源资源地址,这个可以允许服务器生成回退链表,用来
登录、优化缓存等。Referer通常是流量统计系统中用来记录来访者地址的参数</li>
<li>Content Length 内容长度</li>
<li>Content Range 响应的资源范围,可以实现断点续传</li>
<li>Accept Encoding 指定所能接受的编码方式</li>
<li>自定义报头</li>
</ul>
<h3>4.1.3 HTTP应用:灌水机器人</h3>
<ol>
<li>浏览器的工作流程
浏览器就是一个实现了HTTP协议的客户端软件</li>
<li>PHP中和HTTP相关的函数
<code class="inline-code">get_headers(string URL [, intformat])</code>: 取得服务器响应一个http请求所发送的所有报头。
<code class="inline-code">fopen</code>, <code class="inline-code">file_get_contents</code>: 可以用来操作文件,也可以请求一个网络上的资源。
<code class="inline-code">stream_*</code>: 发送请求,包括但不限于http协议
<code class="inline-code">socket</code>系列函数: 统考socket发送和请求数据,包括但不限于http协议
<code class="inline-code">cURL</code>扩展库: 可以用来模拟浏览器和服务器进行交互,功能比较强大
<code class="inline-code">header</code>函数: PHP中可用此函数发送原始的http头。</li>
</ol>
<pre><code class="language-php" data-comment="">&lt;?php
$html = file_get_contents('http://www.baidu.com');
print_r($http_response_header);
$fp = fopen('http://www.baidu.com', 'r');
$result = stream_get_meta_data($fp);
print_r($result);
fclose($fp);</code></pre>
<ol start="3">
<li>模拟灌水机器人
<pre><code class="language-php" data-comment="">$data = array(
'author' =&gt; 'l',
'mail' =&gt; 'info@aiyooyoo.com',
'text' =&gt; '..',
);
$data = http_build_query($data);
$opts = array(
'method' =&gt; 'POST',
'header' =&gt; "Content-type: application/x-www-form-urlencode\r\n".
    "Content-Length: ".strlen($data)."\r\n". 
    "Cookie: PHPSESSID=131aofdiu232\r\n".
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36".
    "Referen: www.baidu.com\r\n",
'content' =&gt; $data,
);
$context = stream_context_create($opts);
$html = @file_get_contents('http://aiyooyoo.com/index.php/archives/comment', false, $context);</code></pre></li>
</ol>
<h3>4.1.4 垃圾信息防御措施</h3>
<ol>
<li>IP限制</li>
<li>验证码</li>
<li>Token和表单欺骗</li>
<li>审核机制</li>
</ol>
<pre><code class="language-php" data-comment="">&lt;?php
// token法
define('SECRET', '67%$&amp;ap28');
function m_token() {
    $str = mt_rand(1000, 9999);
    $str2 = dechex($_SERVER['REQUEST_TIME']-$str);
    return $str.substr(md5($str.SECRET), 0, 10).$str2;
}
echo m_token();
echo '&lt;br/&gt;';
function v_token($str, $delay = 300){
    $rs = substr($str, 0, 4);
    $middle = substr($str, 0, 14);
    $rs2 = substr($str, 14, 8);
    return ($middle == $rs.substr(md5($rs.SECRET), 0, 10)) &amp;&amp; ($_SERVER['REQUEST_TIME']-hexdec($rs2)-$rs &lt; $delay);
}
var_dump(v_token(m_token()));</code></pre>
<h2>4.2 抓包工具</h2>
<h3>4.2.1 抓包工具分类</h3>
<p>常规抓包工具: <code class="inline-code">IRIS</code>,<code class="inline-code">Wireshark</code>
专用抓包工具: <code class="inline-code">HttpWatch</code>, <code class="inline-code">Fiddler</code>, <code class="inline-code">IE Analyzer</code>, <code class="inline-code">Charles</code></p>
<h3>4.2.2 Fiddler功能与原理</h3>
<p>Fiddler是用一款http/https网络调试器,以代理服务器的方式监听系统的网络数据流动。
其工作原理是在浏览器(或者其他使用http协议的进程)和服务器之间扮演代理的角色,
这样所有的通信都要结果它。</p>
<h3>4.2.3 安装Fiddler</h3>
<h3>4.2.4 Fiddler基本页面</h3>
<h3>4.2.5 使用Fiddler进行HTTP断点调试</h3>
<h2>4.3 Socket进程通信机制及应用</h2>
<p><code class="inline-code">socket</code>通常称为套接字,用于描述ip地址和端口,是一个通信链的句柄。
应用程序通过套接字向网络发出请求或者应答网络请求。
socket既不是一个程序,也不是一种协议,其只是操作系统提过的通信层的一组抽象API。</p>
<h3>4.3.1 进程通信相关概念</h3>
<p>本机进程之间的通信:</p>
<ol>
<li>UNIX BSD中的管道</li>
<li>命名管道</li>
<li>软中断信号</li>
<li>UNIX System V的消息</li>
<li>共享存储器</li>
<li>信号量</li>
</ol>
<p>为解决网间进程通信,TPC/IP协议引入了以下概念</p>
<ol>
<li>
<p>端口
网络中可以被命名和寻址的通信端口,是操作系统可分配的一种资源
端口是一种抽象的软件结构(包括一些数据结构和I/O缓冲区)
由于TCP/IP传输层的TCP协议和UDP协议是完全独立的两个软件模块,
因此各自的端口号也相应独立,如TCP有255个端口,UDP也有,二者并不冲突</p>
</li>
<li>地址
网络通信中通信的两个进程分别处在不同的机器上,遵循以下原则</li>
</ol>
<ul>
<li>某台主机可与多个网络相连,必须指定一个特定网络地址</li>
<li>网络上每台主机应有其唯一的地址</li>
<li>每台主机上的每个进程应有在该主机上的唯一标识符</li>
</ul>
<ol start="3">
<li>连接
两个进程间的通信链路称为连接。连接表现为一些缓冲区和一组协议机制</li>
</ol>
<h3>4.3.2 Socket演示:实现服务器端与客户端的交互</h3>
<pre><code class="language-php" data-comment="">&lt;?php
$sock = fsockopen('192.168.0.2', 8001, $errno, $errstr, 1);
if(!sock) {
    echo $errstr($errno), PHP_EOL;
}
else {
    socket_set_blocking($sock, false);
    fwrite($sock, "send data...\r\n");
    fwrite($sock, "end\r\n");
    while(!feof($sock)) {
        echo fread($sock, 128);
        flush();
        ob_flush();
        sleep(1);
    }
    fclose($sock);
}</code></pre>
<h3>4.3.3. socket函数原型</h3>
<pre><code class="language-c" data-comment="">SOCKET socket(int af, int type, int protocol);
</code></pre>
<p>socket从传输模式上又可以分为端对端和点对点的连接,流套接字和数据报套接字都属于端对端
的连接,因此需要绑定端口号。而原始套接字是基于IP协议的,属于点对点的传输模式,是没有端口
这个概念的(如ping)。</p>
<h3>4.3.4 PHP中的socket函数</h3>
<pre><code class="language-php" data-comment="">// 创建一个socket
resource socket_create(int $domain, int $type, int $protocol);
// 将ip地址和端口绑定到socket_create函数创建的句柄中
bool socket_bind(resource $socket, string $address[, int $port=0]);
// 监听客户端数据
bool socket_listen(resource $socket[, int $backlog=0]);
// 设置为非阻塞模式
bool socket_set_block(resource $socket);
// 向socket写入数据
int socket_write(resource $socket, string $buffer[, int $length=0])
// 从socket中读取指定长度的数据
string socket_read(resource $socket, int $length[, int $type=PHP_BINARY_READ])
// 实现长连接
pfsocketopen(string $hostname[, int $port=-1[,int&amp; $errno[,  string&amp; $errstr[, float $timeout=ini_get('default_socket_timeout')]]]]);
// 设置socket的控制选项
bool socket_set_option(resource $socket, int $level, int $optname, mixed $optval);
// 返回操作中任何socket函数产生的最后错误
int socket_last_error([resource $socket]);</code></pre>
<pre><code class="language-php" data-comment="">$host = "127.0.0.1";
$port = 12345;
set_time_limit(0);
$socket = socket_create(AF_INET, SOCK_STREAM, 0) or die("Could not create this socket\n");
$result = socket_bind($socket, $host, $port) or die("Could not bind to socket\n");
$result = socket_listen($socket, 3) or die("Could not set up listener\n");
$spawn = socket_accept($socket) or die("Could not accept incoming connection\n");
$input = socket_read($spawn, 1024) or die("Could not read input \n");
$input = trim($input);
$output = strrev($input)."\n";
socket_write($spawn, $output, strlen($output)) or die ("Could not write output\n");
socket_close($spawn);
socket_close($socket);</code></pre>
<h3>4.3.5 socket交互应用:使用socket抓取数据</h3>
<pre><code class="language-php" data-comment="">$post = array(
    'author' =&gt; '..',
    'mail' =&gt; 'wait@qq.com',
    'url' =&gt; '',
    'text' =&gt; '',
);
$data = http_build_query($post);
$fp = fsockopen('typeecho.org', 80, $errno, $errstr, 5);
$out = "POST http://typecho.org/archives/comment HTTP/1.1\r\n";
$out .= "$data\r\n\r\n";
fwrite($fp, $out);
while (!feof($fp)) {
    echo fgets($fp, 1280);
}
fclose($fp);</code></pre>
<h2>4.4 cURL工具及应用</h2>
<h3>4.4.1 建立cURL请求的基本步骤</h3>
<ol>
<li>初始化</li>
<li>设置选项</li>
<li>执行并获取HTML文档内容</li>
<li>释放cURL句柄</li>
</ol>
<pre><code class="language-php" data-comment="">$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://www.php.net');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CUROOPT_HEADER, 1);
$output = curl_exec($ch);
curl_close($ch);</code></pre>
<h3>4.4.2 检查cURL错误和获取返回信息</h3>
<pre><code class="language-php" data-comment="">@header('Content-type:image/png');
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://renren.com/usr/uploads/2011/06/3230341841.png');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
$output = curl_exec($ch);
$info = curl_getinfo($ch);
curl_close($ch);
file_put_contents('./a.png', $output);
$size = filesize('./a.png');
if($size!=$info['size_download']) {
    echo 'error', PHP_EOL;
}
else {
    echo 'done', PHP_EOL;
}</code></pre>
<h3>4.4.3 在cURL中伪造头信息</h3>
<pre><code class="language-php" data-comment="">@header('Content-type:text/html;charset=utf-8');
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://3g.qq.com');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
$h = array(
    'HTTP_VIA:HTTP/1.1 SNXA-PS-WAP-GW21(infoX-WISG, HuaweiTechnologies)',
    'HTTP_ACCEPT:applicatioin/vnd.wap.wmlscript, text/vnd.wap.wml, application/vnd.wap.html+xml, application/xhtml+xml, text/html, multipart/mixed, */*',
);
curl_setopt($ch, CURLOPT_HTTPHEADER, $h);
$output = curl_exec($ch);
curl_close($ch);</code></pre>
<h3>4.4.4 在cURL中用POST方法发送数据</h3>
<pre><code class="language-php" data-comment="">$url = "http://localhost/post_output.php";
$data = array(
    'foo' =&gt; 'bar',
);
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
$output = curl_exec($ch);
curl_close($ch);
echo $output;</code></pre>
<h3>4.4.5 使用cURL上传文件</h3>
<pre><code class="language-php" data-comment="">$url = "http://localhost/post_output.php";
$data = array(
    'foo' =&gt; 'bar',
    'upload' =&gt; '@test.zip',
);
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
$output = curl_exec($ch);
curl_close($ch);
echo $output;</code></pre>
<h3>4.4.6 cURL批处理</h3>
<pre><code class="language-php" data-comment="">$ch1 = curl_init();
$ch2 = curl_init();
curl_setopt($ch1, CURLOPT_URL, "http://a.php.net");
curl_setopt($ch2, CURLOPT_URL, "http://b.php.net");
$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);
$active = null;
do {
    $mrc = curl_multi_exec($mh, $active);
} while($mrc == CURLM_CALL_MULTI_PERFORM);
while ($active &amp;&amp; $mrc == CURLM_OK) {
    if(curl_multi_select($mh) != -1) {
        do {
            $mrc = curl_multi_exec($mh, $active);
        }while($mrc == CURLM_CALL_MULTI_PERFORM);
    } 
}
curl_multi_remove_handle($mh, $ch1);
curl_multi_remove_handle($mh, $ch2);
curl_multi_close($mh);</code></pre>
<p>这种方式并不是多线程,它属于异步处理的范畴</p>
<h3>4.4.7 cURL设置项</h3>
<p><code class="inline-code">curl_setopt</code>, <code class="inline-code">curl_setopt_array</code></p>
<h3>4.4.8 网络应用:使用cURL抓取腾讯微博</h3>
<ol>
<li>分析抓包数据</li>
<li>登录页面的处理</li>
</ol>
<h2>4.5 简单邮件传输协议SMTP</h2>
<p>要想使用SMTP协议发送邮件,需要安装SMTP服务器或使用socket链接一个已有的服务器,用其发送邮件</p>
<h3>4.5.1 SMTP协议如何工作</h3>
<p>SMTP是由源地址到目的地址传送邮件的一组规则,用来控制信件的中转方式</p>
<p>SMTP协议属于TCP/IP协议族</p>
<p>连接和发送的过程如下</p>
<ol>
<li>建立TCP连接</li>
<li>客户端发送HELO命令以标识发送人自己的身份,客户端发送MAIL命令。服务器以OK作为响应,表明准备接收</li>
<li>使用AUTH命令登录SMTP服务器,输入用户名和密码</li>
<li>客户端发送RCPT命令,标识该邮件的计划接收人,可以有多个RCPT行。服务器以OK作为响应,表示愿意
为收件人发送邮件</li>
<li>协商结束后,使用DATA命令发送</li>
<li>以.号表示结束,输入内容一起发送出去,结束此次发送,用QUIT命令退出</li>
</ol>
<h3>4.5.2 SMTP常用命令</h3>
<p><code class="inline-code">DATA</code>, <code class="inline-code">EXPN</code>, <code class="inline-code">HELO</code>, <code class="inline-code">HELP</code>, <code class="inline-code">MAIL FROM</code>, <code class="inline-code">NOOP</code>, <code class="inline-code">QUIT</code>, <code class="inline-code">RCPT TO</code>,
<code class="inline-code">RSET</code>, <code class="inline-code">SAML FROM</code>, <code class="inline-code">SEND FROM</code>, <code class="inline-code">SOML FROM</code>, <code class="inline-code">TURN</code>, <code class="inline-code">VRFY</code>,</p>
<h3>4.5.3 SMTP协议应用: 使用Socket发送邮件</h3>
<pre><code class="language-php" data-comment="">class SMTP {

    private $host;
    private $port = 25;
    private $user;
    private $pass;
    private $debug = false;
    private $sock;
    private $mail_format = 0;

    function smtp_mail($host, $port, $user, $pass, $format = 1, $debug = 0) {
        $this-&gt;host = $host;
        $this-&gt;port = $port;
        $this-&gt;user = $user;
        $this-&gt;pass = $pass;
        $this-&gt;mail_format = $format;
        $this-&gt;debug = $debug;
        $this-&gt;sock = fsockopen($this-&gt;host, $this-&gt;port, &amp;$errno, &amp;$errstr, 0);
        if(!$this-&gt;sock) {
            exit("Error number: $errno, Error message: $errstr\n");
        }
        $response = fgets($this-&gt;sock);
        if(strstr($response, "220") === false) {
            exit ("server error: $response\n");
        }
    }

    function show_debug($message) {
        if($this-&gt;debug) {
            echo "&lt;p&gt;Debug $message&lt;/p&gt;\n";
        }
    }

    function do_command($cmd, $return_code) {
        fwrite($this-&gt;sock, $cmd);
        $response = fgets($this-&gt;sock);
        if(strstr($response, "$return_code") === false) {
            return false;
        }
        return true;
    }

    function is_email($email) {
        $pattern = "/^[^_][\w]*@[\w.]+[\w]*[^_]$/";
        if(preg_match($pattern, $email, $matches)) {
            return true;
        }
        return false;
    }

    function send_email($from, $to, $subject, $body) {
        if(!$this-&gt;is_email($from) or !$this-&gt;is_email($to)) {
            $this-&gt;show_debug("Please enter vaild from/to email");
            return false;
        }
        if(empty($subject) or empty($body)) {
            $this-&gt;show_debug("Please enter subject/content");
            return false;
        }
        $detail = "From: $from\r\n";
        $detail .= "To: $to\r\n";
        if($this-&gt;mail_format == 1) {
            $detail .= "Content-Type: text/html;\r\n";
        } else {
            $detail .= "Content-Type: text/plain;\r\n";
        }
        $detail .= "charset=gb2312\r\n\r\n";
        $detail .= $body;
        $this-&gt;do_command("HELO smtp.qq.com\r\n", 250);
        $this-&gt;do_command("AUTH LOGIN\r\n", 334);
        $this-&gt;do_command($this-&gt;user."\r\n", 334);
        $this-&gt;do_command($this-&gt;pass."\r\n", 235);
        $this-&gt;do_command("MAIL FROM:$from\r\n", 250);
        $this-&gt;do_command("RCPT TO: $to\r\n", 250);
        $this-&gt;do_command("DATA\r\n", 354);
        $this-&gt;do_command("$detail\r\n.\r\n", 250);
        $this-&gt;do_command("QUIT\r\n", 221);
        return true;
    }
}</code></pre>
<h2>4.6 WebService的前世今生</h2>
<h3>4.6.1 WebService简介</h3>
<p>广义的Webservice可以实现硬件和软件,硬件和硬件,软件和软件之间的通信</p>
<h3>4.6.2 认识PHPRPC协议</h3>
<p>PHPRPC是一个轻型的,安全的,跨国际的,跨语言的,跨平台的,跨环境的,跨域的协议,支持复杂
对象传输,引用参数传输,内容输出重定向,分级错误处理,会话,是面向服务的高性能远程调用协议</p>
<h3>4.6.3 Web服务的实现模式</h3>
<p>PHP支持两中Web服务模式:<code class="inline-code">WSDL</code>和<code class="inline-code">non WSDL</code></p>
<p>Web服务主要有两种实现模式:<code class="inline-code">契约先行模式</code>,<code class="inline-code">代码先行模式</code></p>
<p>契约先行模式的实现中,首要工作是定义正对这个Web服务接口的WSDL文件,契约订立之后,再据此
进行服务器端和客户端应用程序的开发
<a href="http:www.w3cshool.com.cn/swdl">WSDL文件详细介绍</a></p>
<p>代码先行模式,第一步工作是实现Web服务端,根据服务端的实现,用某种方法(自动生成或手工编写)
生成WSDL文件</p>
<h3>4.6.4 简单对象访问协议SOAP</h3>
<p><code class="inline-code">SOAP</code>是基于XML的,可扩展的通信协议
SOAP具有可扩展性和平台无关性</p>
<h3>4.6.5 调试工具soapUI</h3>
<p><a href="http://www.soapui.org">下载链接</a></p>
<h2>4.7 Cookie详解</h2>
<h3>4.7.1 Cookie的基本概念及设置</h3>
<p><code class="inline-code">Cookie</code>是存储在客户端的一小段数据,浏览器通过HTTP协议和服务器端景象Cookie交互
Cookie是由浏览器实现和管理的,Cookie和PHP没有任何关系,只和浏览器相关,PHP只负责和客户
端打招呼,具体管理由客户端全程完成</p>
<pre><code class="language-php" data-comment="">bool setcookie(string $name[,string $value[, int $expire=0[, string $path[, string $domain[, $secure=false], bool $httponly=false]]]]]])</code></pre>
<p>由PHP在当前页设置的Cookie并不能立即生效,要等到下一个页面才能看到。
Cookie没有显式删除函数,但是可以设置过期时间</p>
<h3>4.7.2 PHP和JavaScript对Cookie的操作</h3>
<pre><code class="language-php" data-comment="">setcookie('vote', 'k100', time_3600);
print_r($_COOKIE];</code></pre>
<h3>4.7.3 Cookie存储机制及应用</h3>
<p>每个域名下允许的Cookie数量是有限制的
每个Cookie最大字节数也是有限制的
Cookie会增加带宽</p>
<h3>4.7.4 Cookie跨域与P3P协议</h3>
<p>正常的Cookie只能在一个应用中共享,即一个Cookie只能由创建它的应用获得。
实现Cookie的跨域,主要是为了统一应用平台,即实现单点登录</p>
<p>P3P协议由万维网协会研制,为Web用户提供了对自己公开信息的更多控制。</p>
<p>Cookie跨域设计两个不同的应用,习惯上称为第一方和第三方
第一方Cookie来自正在查看的网站,或者发送到目前正在查看的网站
第三方Cookie来自当前正在查看的网站以外的网站,或者发送到当前正在查看的网站以外的网站</p>
<p>步骤</p>
<ol>
<li>在host文件添加测试域名
127.0.0.1 www.atest.com
127.0.0.1 www.btest.com</li>
<li>访问www.atest.com时调用www.btest.com的页面,种下Cookie
<pre><code class="language-js" data-comment="">&lt;script src="http://www.btest.com/t/get.php?id=1000&gt;&lt;script&gt;</code></pre>
<pre><code class="language-php" data-comment="">header('P3P:Cp="CURa ADMa-dEVa PSAo ....."');
setcookie('p3p', $_GET['id'], time()+3600, "/", ".btest.com");</code></pre>
<pre><code class="language-php" data-comment="">var_dump($_COOKIE);</code></pre></li>
</ol>
<h3>4.7.5 本地存储localStorage</h3>
<p>HTML5本地存储只能存储字符串,任何格式存储的时候都会被自动转为字符串</p>
<h2>4.8 Session详解</h2>
<p><code class="inline-code">Session</code>即会话,指一种持续的、双向的连接   </p>
<h3>4.8.1 Session的基本概念及设置</h3>
<p>Session指用户在浏览某个网站时,从进入网站到浏览器光比这段时间内的会话</p>
<h3>4.8.4 Session工作原理</h3>
<p>Session通过一个称为PHPSESSID的Cookie和服务器联系,Session是通过SessionID
判断客户端用户的,即Session文件的文件名
Session以文件的形式存放在本地硬盘的一个目录中,所以Session比较多时,磁盘读取文件就会比较慢
对于设置分级目录存储的Session,PHP不会自动回收,需要自己实现其回收机制</p>
<h3>4.8.3 Session入库</h3>
<pre><code class="language-php" data-comment="">bool session_set_save_handler(callback open, callback close, callback read, callback write, callback destroy, callback gc)</code></pre>
<p>在大流量的网站中,Session入库存在效率不高,占数据库connection资源等问题。
针对这种情况,可以使用Memcached、Redis等key value数据存储方案实现高并发
大流量的Session存储。</p>
<h3>4.8.4 Cookie与Session问答</h3>
<ol>
<li>
<p>Cookie运行在客户端,Session运行在服务端,对吗
不完全正确,Cookie是运行在客户端,由客户端进行管理;
Session虽然运行在服务端,但是SessionID作为一个Cookie存储在客户端</p>
</li>
<li>
<p>浏览器禁止Cookie,Cookie就不能用了,但Session不会受浏览器影响,对吗
错。浏览器禁止Cookie,Cookie确实不能用了,Session会受浏览器的影响</p>
</li>
<li>
<p>浏览器关闭后,Cookie和Session都消失了对吗
错。存储在内存中的Cookie会随着浏览器的关闭而消失,但存储在硬盘上的不会,
Session在浏览器关闭后不会消失,除非正常退出,代码显式删除Session</p>
</li>
<li>
<p>Session比Cookie更安全吗,不应该大量使用Cookie吗
错,通常情况下,Cookie和Session是绑定的,获得Cookie就相当于获取了Session,
不存在Session比Cookie更安全的说法</p>
</li>
<li>
<p>Session创建在服务器上,应该少用Session而多用Cookie对吗
错,Cookie可以提高用户体验,但会加大网络之间的数据传输量</p>
</li>
<li>
<p>如果别人把Cookie复制到我电脑上,是不是能够登录别人的账号
是,要避免这种情况,需要在Cookie中针对ip、ua等加上特殊校验信息,然后和服务器端比对</p>
</li>
<li>在ie登录网站,换成firefox登录状态如何
不同浏览器使用不同的Cookie管理机制,无法共用Cookie</li>
</ol>
<h2>4.9 本章小结</h2>
<h6>2018.02.20</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>