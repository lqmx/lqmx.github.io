<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1522078208">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Linux下select, poll和epoll IO模型</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1522078208">
    <link rel="stylesheet" href="../../css/reset.css?v1522078208">
    <link rel="stylesheet" href="../../css/md.css?v1522078208">
    <link rel="stylesheet" href="../../css/module.css?v1522078208">
    <link rel="stylesheet" href="../../css/c.css?v1522078208">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1522078208">
    <script src="../../dep/require.js?1522078208"></script>
</head>
<body>
    <div class="md"><h1>Linux下select, poll和epoll IO模型</h1>
<h6>2018.03.19</h6>
<h2>Epoll介绍</h2>
<p>Epoll在Linux2.6内核中引入,和select相似,都是I/O多路复用技术。</p>
<h2>常用模型的缺点</h2>
<ol>
<li>PPC/TPC模型</li>
</ol>
<p>让每一个到来的连接以便自己做事去,别再来烦我。</p>
<p>PPC开进程、TPC开线程</p>
<p>需要时间和空间,连接多了以后进程和线程的切换开销较大,最大连接数不高</p>
<ol start="2">
<li>SELECT模型</li>
</ol>
<p>select最早出现于4.2BSD中,它通过select()系统调用来监视多个文件描述符的数组,
当select()返回后,该数组中就绪的文件描述符便会被内核修改标志位,使得进程可以
获得这些文件描述符从而进行后续的读写操作。</p>
<p>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</p>
<p>另外,select()所维护的存储大量文件描述符的数据结构,随着文件描述符数量的增大,
其复制的开销也线性增长,同时游湖网络响应时间的延迟使得大量TCP连接处于非活跃状态,
但调用select也会对所有socket进行一次线性扫描</p>
<p>I/O时间到来时,通知应用程序有事件到了快去处理,应用程序轮询所有的FD集合,
检测每个FD是否由事件发生,并处理事件</p>
<pre><code class="language-c" data-comment="">int res = select(maxfd+1, &amp;readfds, NULE, NULL, 120);
if(res &gt; 0) {
    for(int i = 0; i &lt; MAX_CONNECTION; i++) {
        if(FD_ISSET(allConnection[i], &amp;readfds)) {
            handleEvent(allConnection[i];
        }
    }
}</code></pre>
<ul>
<li>最大并发数限制</li>
<li>效率问题,SELECT每次调用都会线性扫描全部的FD(文件描述符)集合</li>
<li>内核/用户空间内存拷贝问题</li>
</ul>
<p>总结:连接数受限,查找配对速度慢,数据由内核拷贝到用户态</p>
<ol start="3">
<li>poll模型</li>
</ol>
<p>本质上和select相同,但是没有最大文件描述符数量的限制</p>
<p>基本上效率和SELECT相同</p>
<h2>Epoll的提升</h2>
<p>epoll只告知那些就绪的文件描述符,采用内存映射技术,省掉了这些文件描述符
在系统调用时复制的开销。</p>
<p>epoll采用基于时间的就绪通知方式,一旦基于某个文件描述符就绪时,内核会采用
类似callback的回调机制,激活这个文件描述符。</p>
<ul>
<li>没有最大并发连接的限制</li>
<li>效率提升,只管活跃的连接</li>
<li>内存拷贝</li>
</ul>
<h2>Epoll高效的原因</h2>
<p>Epoll不仅会告诉应用程序有I/O事件到来,还会告诉应用程序相关的信息,根据
这些信息应用程序能直接定位到事件,而不必遍历整个FD集合</p>
<pre><code class="language-c" data-comment="">int res = epoll_wait(epfd, events, 20, 120);
for(int i = 0; i &lt; res; i ++) {
    handlerEvent(events[i]);
}</code></pre>
<h2>Epoll关键数据结构</h2>
<pre><code class="language-c" data-comment="">struct epoll_event {
    __uint32_t event;
    epoll_data_t data;
;
typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;</code></pre>
<h2>参考</h2>
<ul>
<li><a href="http://blog.csdn.net/tianmohust/article/details/6677985">Linux下select, poll和epoll IO模型的详解</a></li>
</ul>
<h6>2018.03.26</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>