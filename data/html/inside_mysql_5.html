<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520522507">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第五章 索引与算法</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520522507">
    <link rel="stylesheet" href="../../css/reset.css?v1520522507">
    <link rel="stylesheet" href="../../css/md.css?v1520522507">
    <link rel="stylesheet" href="../../css/module.css?v1520522507">
    <link rel="stylesheet" href="../../css/c.css?v1520522507">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520522507">
    <script src="../../dep/require.js?1520522507"></script>
</head>
<body>
    <div class="md"><h1>第五章 索引与算法</h1>
<h6>2018.03.04</h6>
<h2>5.1 InnoDB存储引擎索引概述</h2>
<p>InnoDB支持以下三种索引</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>InnoDB支持的哈希索引是自适应的,InnoDB会根据表的使用情况自动为表生成哈希索引,不能人为
干预是否在一张表中生成哈希索引。</p>
<p>B+树索引结构类似二叉树,B+树种的B不是代表二叉,而是代表平衡</p>
<p>B+树索引并不能找到一个给定键值的具体行,需要先找到行所在的页,读入内存后二叉查找到记录。</p>
<h2>5.2 数据结构与算法</h2>
<h3>5.2.1 二分查找法</h3>
<p>每页Page Directory中的槽是按照主键的顺序存放的,对于某一条具体记录的查询是通过对Page
Directory进行二分查找得到的。</p>
<h3>5.2.2 二叉查找树和平衡二叉树</h3>
<p>B+树是通过二叉查找树,再由平衡二叉树,B树演化而来。</p>
<p>在二叉查找树种,左子树的键值总是小于根的键值,右子树的键值总是大于根的键值。</p>
<p>平衡二叉树(AVL树)首先符合二叉查找树的定义,其次必须满足任何节点的两个子树的高度差为1.</p>
<h2>B+树</h2>
<p>B+树由B树和索引顺序访问方法演化而来</p>
<p>B+树是为磁盘或其他直接存放辅助设备设计的一种平衡查找树。在B+树种,所有记录节点都是按键值
的大小顺序存放在同一层的叶子节点上,由各个叶子节点指针进行连接。</p>
<h3>B+树的插入操作</h3>
<ul>
<li>Leaf Page满 拆分叶子节点</li>
<li>Index Page满 拆分Index Page,减少页拆分,提供类似旋转功能</li>
</ul>
<h3>B+树的删除操作</h3>
<ul>
<li>叶子节点小于填充因子</li>
<li>中间节点小于填充因子</li>
</ul>
<h2>5.4 B+树索引</h2>
<p>B+索引在数据库中有一个特点是高扇出性,因此在数据库中,B+树的高度一般都在2-4层。</p>
<p>数据库中B+树索引可以分为聚集索引和辅助索引。聚集索引与辅助索引不同的是,叶子节点存放的是否
是一整行的信息。</p>
<h3>5.4.1 聚集索引</h3>
<p>聚集索引按每张表的主键构造一棵B+树,同时叶子节点中存放的即为整张表的行记录数据,也将聚集索引
的叶子节点称为数据页。</p>
<p>聚集索引能够在B+树索引的叶子节点上直接找到数据。</p>
<p>聚集索引的存储并不是物理上连续的,而是逻辑上连续的。</p>
<ul>
<li>页通过双向链表链接,页按照主键的顺序排序</li>
<li>每个页中的记录也是通过双向链表进行维护的,物理存储上可以同样不按照主键存储</li>
</ul>
<p>聚集索引的另一个好处是,它对于主键的排序查找和范围查找速度非常快。</p>
<h3>5.4.2 辅助索引</h3>
<p>对于辅助索引,叶子节点并不包含行记录的全部数据。</p>
<p>辅助索引的存在不影响数据在聚集索引中的组织,每张表可以有多个辅助索引。</p>
<p>通过辅助索引来查找数据时,InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键,
然后再通过主键索引来找到一个完整的行记录。</p>
<h3>5.4.3 B+树索引的分裂</h3>
<h3>5.4.4 B+树索引的管理</h3>
<ol>
<li>索引管理</li>
</ol>
<pre><code class="language-mysql" data-comment="">alter table t add key idx_b(b(100));
show index from t;</code></pre>
<ul>
<li>Table 索引所在的表名</li>
<li>Non_unique 非唯一索引</li>
<li>Key_name 索引的名字</li>
<li>Seq_in_index 索引在该列的位置</li>
<li>Column_name 索引列的名称</li>
<li>Collation 列以什么形式存储在索引中</li>
<li>Cardinality 索引唯一值的数目</li>
<li>Sub_part 是否是列的部分被索引</li>
<li>Packed 关键字如何被压缩</li>
<li>Null 列是否含有null</li>
<li>Index_type 索引的类型</li>
<li>Comment 注释</li>
</ul>
<ol start="2">
<li>Fast Index Creation</li>
</ol>
<p>MySQL5.5版本之前,存在一个普遍被人诟病的问题: 在对于索引的添加或者删除的这类DDL操作,过程为</p>
<ul>
<li>首先先建一张临时表,表结构通过alter table新定义的结构</li>
<li>然后把原表的数据导入到临时表</li>
<li>接着删除原表</li>
<li>最后把临时表重命名为原来的表名</li>
</ul>
<p>InnoDB1.0.x开始支持Fast Index Creation</p>
<ul>
<li>创建: 对创建索引的表加上一个S锁。不需要重建表。</li>
<li>删除: 更新内部视图,并将辅助索引的空间标记为可用,同时删除内部视图上对该表的索引定义</li>
</ul>
<p>FIC方式只限于辅助索引,对于主键的创建和删除同样需要重建一张表。</p>
<ol start="3">
<li>Online Schema Change</li>
</ol>
<p>在线是指在事务的创建过程中,可以有读写事务对表进行操作。</p>
<p>OSC实现,是一个PHP脚本,要求进行修改的表要有主键,且表本身不能存在外键和触发器。</p>
<ol start="4">
<li>Online DDL</li>
</ol>
<p>允许辅助索引创建的同时,还允许诸如Insert、update、delete的DML操作</p>
<p>以下DDL可以通过'在线'的方式进行操作</p>
<ul>
<li>辅助索引的创建和删除</li>
<li>改变自增长值</li>
<li>添加或删除外键约束</li>
<li>列的重命名</li>
</ul>
<pre><code class="language-txt" data-comment="">alter table tbl_name
| add {index|key} [index_name]
[index_type] (index_col_name, ...) [index_option] ...
algorithm [=] {default|inplace|copy}
lock [=] {default|none|shared|exclusive}</code></pre>
<p>algorithm指定创建或删除索引的算法</p>
<ul>
<li>copy 创建临时表的方式</li>
<li>inplace 不需要创建临时表</li>
<li>default 根据<code class="inline-code">old_alter_table</code>来判断是通过inplace还是copy</li>
</ul>
<p>lock为创建或删除索引对表添加锁的情况</p>
<ul>
<li>none 不添加任何锁</li>
<li>share 加s锁</li>
<li>exclusive 加s锁</li>
<li>default 以none到share到exclusive依次判断是否可用</li>
</ul>
<p>实现Online DDL原理为:在创建或删除同时,将insert、update、delete这类DML操作日志写入缓存。
完成后索引操作后重做应用到表上。</p>
<h2>5.5 Cardinality值</h2>
<h3>5.5.1 什么是Cardinality</h3>
<p>Cardinality表示索引中不重复记录数量的预估值。</p>
<p>Cardinality/n_row_in_table 应该接近于1,否则考虑是否需要索引</p>
<h3>5.5.2 InnoDB存储引擎的Cardinality统计</h3>
<p>Cardinality的统计是放在存储引擎层的。</p>
<p>数据库对于Cardinality的统计是通过采样的方式来完成的。</p>
<p>InnoDB对更新Cardinality的策略为:</p>
<ul>
<li>表中1/16的数据已发生改变</li>
<li>stat_modified_counter &gt; 2 000 000 000</li>
</ul>
<p>InnoDB中,Cardinality值是通过对8个叶子节点预估而得的,不是一个实际精确的值。</p>
<h2>5.6 B+树索引的应用</h2>
<h3>5.6.1 不同应用中B+树索引的使用</h3>
<h3>5.6.2 联合索引</h3>
<p>联合索引是指对表上的多个列进行索引。</p>
<p>联合索引在叶子节点已经排好序了。</p>
<p>对于联合索引(a,b),<code class="inline-code">select ... from table where a=xxx order by b</code>可以直接使用联合索引得到结果。</p>
<h3>5.6.3 覆盖索引</h3>
<p>覆盖索引:从辅助索引中就可以得到查询的记录,而不需要查询聚集索引中的记录。</p>
<p>下面语句都可仅用一次辅助联合索引来完成查询:</p>
<pre><code class="language-mysql" data-comment="">select key2 from table where key1=xxx;
select primary key2,key2 from table where key1=xxx;
select primary key1,primary key2, key2 from table where key1=xxx;</code></pre>
<h3>5.6.4 优化器选择不适用索引的情况</h3>
<p>对于不能进行索引覆盖的情况,优化器选择辅助索引的情况是,通过辅助索引查找的数据是少量的。</p>
<h3>5.6.5 索引提示</h3>
<p>使用索引提示的情况</p>
<ul>
<li>MySQL优化器错误的选择了某个索引,导致SQL运行慢</li>
<li>某SQL语句可以选择的索引比较多,优化器选择执行计划时间的开销大于SQL语句本身</li>
</ul>
<pre><code class="language-mysql" data-comment="">select * from t use index(a) where a = 1 and b = 2;
select * from t force index(a) where a = 1 and b = 2;</code></pre>
<h3>5.6.6 Multi-Range Read 优化</h3>
<p>Multi-Range Read优化的目的是为了减少磁盘的随机访问,并且将随机访问转化为较顺序的数据访问。</p>
<p>MRR好处:</p>
<ul>
<li>MMR使数据访问变得顺序。在查询辅助索引时,先根据得到的查询结果,按照主键进行排序,并按照主键
排序的顺序进行书签查找</li>
<li>减少缓冲池中页被替换的次数</li>
<li>批量处理对键值的查询操作</li>
</ul>
<p>InnoDB和MyISAM的范围查找和JOIN查找,MRR工作方式如下:</p>
<ul>
<li>将查询得到的辅助索引键值存放在一个缓存中,这是缓存中的数据是根据辅助索引排序的</li>
<li>将缓存中的键值更加rowid排序</li>
<li>根据rowid排序顺序访问实际的数据文件</li>
</ul>
<p>MRR可以将某些范围查询,拆分为键值对,以此来进行批量的数据查询,在拆分过程中,直接过滤一些不符合
查询条件的数据。</p>
<pre><code class="language-mysql" data-comment="">set @@optimizer_switch='mrr=on,mrr_cost_based=off';</code></pre>
<h3>5.6.7 Index Condition Pushdown(ICP)优化</h3>
<p>在取出索引的同事,判断是否可以进行where条件过滤,也就是将where的部分过滤操作放在了存储引擎层。</p>
<h2>5.7 哈希算法</h2>
<h3>5.7.1 哈希表</h3>
<p>哈希表也称散列表,由直接寻址表改进而来。</p>
<h3>5.7.2 InnoDB存储引擎中的哈希算法</h3>
<p>InnoDB使用哈希算法来对字典进行查找,其冲突机制采用链表方式,哈希函数采用除法散列方式。</p>
<h3>5.7.3 自适应哈希索引</h3>
<p>哈希索引智能用来搜索等值的查询。</p>
<h2>5.8 全文检索</h2>
<h3>5.8.1 概述</h3>
<p>全文检索是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。</p>
<h3>5.8.2 倒排索引</h3>
<p>全文检索通常使用倒排索引来实现。倒排索引用B+树索引一样,也是一种索引结构。它在辅助表中存储
了单词与单词自身在一个或多个文档中所在位置之间的映射。通常利用关联数组实现,拥有两种表现形式:</p>
<ul>
<li>inverted file index,其表现形式为{单词,单词所在文档的ID}</li>
<li>full inverted index,其表现形式为{单词,(单词所在文档ID,在具体文档中的位置)}</li>
</ul>
<h3>5.8.3 InnoDB全文检索</h3>
<p>在InnoDB中,将(DocumentId, Position)视为一个'ilist'。因此在全文检索的表中,有两个列,
一个是word字段,另一个是ilist字段,并且在word字段上有索引。</p>
<p>倒排索引将word存在Auxiliary Table中,该表存放在磁盘上。</p>
<p>FTS Index Cache是一个红黑树结构,其根据(word,ilist)进行排序,用来提高全文检索的性能。</p>
<h6>2018.03.08</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>