<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520384151">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第五章 索引与算法</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520384151">
    <link rel="stylesheet" href="../../css/reset.css?v1520384151">
    <link rel="stylesheet" href="../../css/md.css?v1520384151">
    <link rel="stylesheet" href="../../css/module.css?v1520384151">
    <link rel="stylesheet" href="../../css/c.css?v1520384151">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520384151">
    <script src="../../dep/require.js?1520384151"></script>
</head>
<body>
    <div class="md"><h1>第五章 索引与算法</h1>
<h6>2018.03.04</h6>
<h2>5.1 InnoDB存储引擎索引概述</h2>
<p>InnoDB支持以下三种索引</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>InnoDB支持的哈希索引是自适应的,InnoDB会根据表的使用情况自动为表生成哈希索引,不能人为
干预是否在一张表中生成哈希索引。</p>
<p>B+树索引结构类似二叉树,B+树种的B不是代表二叉,而是代表平衡</p>
<p>B+树索引并不能找到一个给定键值的具体行,需要先找到行所在的页,读入内存后二叉查找到记录。</p>
<h2>5.2 数据结构与算法</h2>
<h3>5.2.1 二分查找法</h3>
<p>每页Page Directory中的槽是按照主键的顺序存放的,对于某一条具体记录的查询是通过对Page
Directory进行二分查找得到的。</p>
<h3>5.2.2 二叉查找树和平衡二叉树</h3>
<p>B+树是通过二叉查找树,再由平衡二叉树,B树演化而来。</p>
<p>在二叉查找树种,左子树的键值总是小于根的键值,右子树的键值总是大于根的键值。</p>
<p>平衡二叉树(AVL树)首先符合二叉查找树的定义,其次必须满足任何节点的两个子树的高度差为1.</p>
<h2>B+树</h2>
<p>B+树由B树和索引顺序访问方法演化而来</p>
<p>B+树是为磁盘或其他直接存放辅助设备设计的一种平衡查找树。在B+树种,所有记录节点都是按键值
的大小顺序存放在同一层的叶子节点上,由各个叶子节点指针进行连接。</p>
<h3>B+树的插入操作</h3>
<ul>
<li>Leaf Page满 拆分叶子节点</li>
<li>Index Page满 拆分Index Page,减少页拆分,提供类似旋转功能</li>
</ul>
<h3>B+树的删除操作</h3>
<ul>
<li>叶子节点小于填充因子</li>
<li>中间节点小于填充因子</li>
</ul>
<h2>5.4 B+树索引</h2>
<p>B+索引在数据库中有一个特点是高扇出性,因此在数据库中,B+树的高度一般都在2-4层。</p>
<p>数据库中B+树索引可以分为聚集索引和辅助索引。聚集索引与辅助索引不同的是,叶子节点存放的是否
是一整行的信息。</p>
<h3>5.4.1 聚集索引</h3>
<p>聚集索引按每张表的主键构造一棵B+树,同时叶子节点中存放的即为整张表的行记录数据,也将聚集索引
的叶子节点称为数据页。</p>
<p>聚集索引能够在B+树索引的叶子节点上直接找到数据。</p>
<p>聚集索引的存储并不是物理上连续的,而是逻辑上连续的。</p>
<ul>
<li>页通过双向链表链接,页按照主键的顺序排序</li>
<li>每个页中的记录也是通过双向链表进行维护的,物理存储上可以同样不按照主键存储</li>
</ul>
<p>聚集索引的另一个好处是,它对于主键的排序查找和范围查找速度非常快。</p>
<h3>5.4.2 辅助索引</h3>
<p>对于辅助索引,叶子节点并不包含行记录的全部数据。</p>
<p>辅助索引的存在不影响数据在聚集索引中的组织,每张表可以有多个辅助索引。</p>
<p>通过辅助索引来查找数据时,InnoDB会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键,
然后再通过主键索引来找到一个完整的行记录。</p>
<h3>5.4.3 B+树索引的分裂</h3>
<h3>5.4.4 B+树索引的管理</h3>
<ol>
<li>索引管理</li>
</ol>
<pre><code class="language-mysql" data-comment="">alter table t add key idx_b(b(100));
show index from t;</code></pre>
<ul>
<li>Table 索引所在的表名</li>
<li>Non_unique 非唯一索引</li>
<li>Key_name 索引的名字</li>
<li>Seq_in_index 索引在该列的位置</li>
<li>Column_name 索引列的名称</li>
<li>Collation 列以什么形式存储在索引中</li>
<li>Cardinality 索引唯一值的数目</li>
<li>Sub_part 是否是列的部分被索引</li>
<li>Packed 关键字如何被压缩</li>
<li>Null 列是否含有null</li>
<li>Index_type 索引的类型</li>
<li>Comment 注释</li>
</ul>
<h6>2018.03.07</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>