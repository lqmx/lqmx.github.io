<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1520065964">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>MySQL技术内幕 第二章 InnoDB存储引擎</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1520065964">
    <link rel="stylesheet" href="../../css/reset.css?v1520065964">
    <link rel="stylesheet" href="../../css/md.css?v1520065964">
    <link rel="stylesheet" href="../../css/module.css?v1520065964">
    <link rel="stylesheet" href="../../css/c.css?v1520065964">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1520065964">
    <script src="../../dep/require.js?1520065964"></script>
</head>
<body>
    <div class="md"><h1>第二章 InnoDB存储引擎</h1>
<h6>2018.03.01</h6>
<h2>2.1 InnoDB存储引擎概述</h2>
<p>InnoDB是第一个完整支持ACID事务的MySQL存储引擎,其特点是行锁设计、支持MVCC、支持外键、
提供一致性非锁定读,同时被设计用来最有效地利用以及使用内存和CPU。</p>
<h2>2.2 InnoDB存储引擎的版本k</h2>
<h2>2.3 InnoDB体系架构</h2>
<p>InnoDB有多个内存块,负责:</p>
<ol>
<li>维护所有进程/线程需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据,方便快速地读取,同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>重做日志缓冲</li>
</ol>
<p>后台线程的作用:</p>
<ol>
<li>刷新内存池中的数据,保证缓冲池中的内存缓存的是最近的数据</li>
<li>将已修改的数据文件刷新到磁盘文件</li>
<li>保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态</li>
</ol>
<h3>2.3.1 后台线程</h3>
<ol>
<li>Master Thread</li>
</ol>
<p>将缓冲池中的数据异步刷新到磁盘,保证数据的一致性,包括脏页的刷新、合并插入缓冲、undo页的回收等。</p>
<ol start="2">
<li>IO Thread</li>
</ol>
<p>InnoDB有write、read、insert buffer和log IO thread</p>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_version';
show variables like 'innodb_%io_threads';
show engin innodb status;</code></pre>
<ol start="3">
<li>Purge Thread</li>
</ol>
<p>事务被提交后,其所使用的undo log可能不在需要,Purge Thread负责回收已经使用并分配的undo页</p>
<pre><code class="language-ini" data-comment="">[mysqld]
innodb_purge_threads=1</code></pre>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_purge_threads';</code></pre>
<ol start="4">
<li>Page Cleaner Thread</li>
</ol>
<p>其作用是将之前版本中的脏页的刷新操作都放入到单独的线程中来完成,减轻原Master Thread的工作
及对于用户查询线程的阻塞,提高InnoDB的性能</p>
<h3>2.3.2 内存</h3>
<ol>
<li>缓冲池</li>
</ol>
<p>缓冲池简单来说就是一块内存区域,通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。</p>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_buffer_pool_size';</code></pre>
<p>缓冲池中缓存的数据页类型有:索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB的锁信息、
数据字典信息等。</p>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_buffer_pool_instance';
show engin innodb status;
select pool_id, pool_size, free_buffers, database_paces from innodb_buffer_pool_status;</code></pre>
<ol start="2">
<li>LRU List、Free List和Flush List</li>
</ol>
<p>数据库中的缓冲池通过LRU(最近最少使用)算法来管理。</p>
<p>缓存池中页的大小默认为16KB</p>
<p>InnoDB对传统的LRU算法做了一些优化,引入midpoint,算法为midpoint insertion strategy</p>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_old_blocks_pct';</code></pre>
<pre><code class="language-mysql" data-comment="">sel global innodb_old_blocks_time=1000;
set global innodb_old_blocks_time=0;
set global innodb_old_blocks_pct=20;</code></pre>
<pre><code class="language-mysql" data-comment=""># 缓冲池的状态
select pool_id, hit_hate, pages_made_young, page_not_made_young from 
information_schema.innodb_buffer_pool_status;
# LRU列表中SPACE为1的表的页类型
select table_name, space, page_number, page_type from innodb_buffer_page_lru
where space = 1;</code></pre>
<p>需要从缓冲池中申请页为4KB的大小,过程为:</p>
<ul>
<li>检查4KB的unzip_LRU列表,检查是否有可用的空闲页</li>
<li>若有,则直接使用</li>
<li>否则,检查8KB的unzip_LRU列表</li>
<li>若能得到空闲页,将页分为两个4KB的页,存放到4KB的unzip_LRU列表</li>
<li>若不能得到空闲页,从LRU列表申请一个16KB的页,风味一个8KB两个4KB的页,分别放入对应的unzip_LRU中</li>
</ul>
<pre><code class="language-mysql" data-comment=""># 查看unzip_LRU页
select table_name, space, page_number, compressed_size from innodb_buffer_page_lru
where compressed_size &lt;&gt;0;</code></pre>
<pre><code class="language-mysql" data-comment=""># 查看脏页的情况
select table_name, spacee, page_number, page_type from innodb_buffer_page_lru
where oldest_modification &gt; 0;</code></pre>
<p>LRU List用来管理已经读取的页
Free List用来管理空闲页
Flush List用来管理脏页(在LRU列表中被修改的页)</p>
<ol start="3">
<li>重做日志缓冲</li>
</ol>
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_log_buffer_size';</code></pre>
<p>重做日志在下列情况会将日志缓冲中的内存刷新到外部磁盘的重做日志文件中:</p>
<ul>
<li>Master Thread每一秒执行</li>
<li>每个事务提交时</li>
<li>当重做日志缓冲池剩余空间小于1/2时</li>
</ul>
<ol start="4">
<li>额外的内存池</li>
</ol>
<p>在对一些数据结构本身的内存进行分配时,需要从额外的内存池中申请,当该区域的内存不够时,会从
缓冲池中申请。</p>
<h3>2.4 Checkpoint技术</h3>
<p>当前事务数据库普遍都采用了Write Ahead Log策略,即当前事务提交时,先做重做日志,在修改页。</p>
<p>Checkpoint技术的目的解决了以下几个问题:</p>
<ul>
<li>缩短数据库的回复时间</li>
<li>缓冲池不够用时,将脏页刷新到磁盘</li>
<li>重做日志不可用时,刷新脏页</li>
</ul>
<p>在InnoDB存储引擎内部,有两种Checkpoint</p>
<ul>
<li>Sharp Checkpoint 发生在数据库关闭时将所有的脏页都刷新回磁盘</li>
<li>Fuzzy Checkpoint 数据库运行时,只刷新部分脏页</li>
</ul>
<p>在InnoDB中可能发生几种情况的Fuzzy Checkpoint</p>
<ul>
<li>Master Thread Checkpoint 每秒或每十秒刷新一定比例,异步</li>
<li>FLUSH_LRU_LIST Checkpoint 保证LRU列表中有足够的空闲页可供使用</li>
<li>Async/Sync Flush Checkpoint 重做日志文件不可用的情况,需要强制将一些页刷新回磁盘,保证
重做日志的循环使用。</li>
</ul>
<blockquote class="bq5">
<p>checkpoint_age = redo_lsn = checkpoint_lsn</p>
<p>async_water_mark = 0.75 * total_redo_log_file_size</p>
<p>sync_water_mark = 0.90 * total_redo_log_file_size</p>
<p>当checkpoint_age &lt; async_water_mark, 不需要刷新脏页到磁盘</p>
<p>当async_water_mark &lt; checkpoint_age &lt; sync_water_mark, 触发Async Flush,从Flush
列表刷新足够的脏页回磁盘</p>
<p>当checkpoint_age &gt; async_water_mark, 触发Sync Flush,从Flush列表刷新足够的脏页
会磁盘</p>
</blockquote>
<ul>
<li>Dirty Page too much Checkpoint 脏页数量太多导致引擎强制进行Checkpoint
<pre><code class="language-mysql" data-comment="">show variables like 'innodb_max_dirty_pages_pct';</code></pre></li>
</ul>
<h2>2.5 Master Thread 工作方式</h2>
<h3>2.5.1 InnoDB 1.0.x版本之前的Master Thread</h3>
<pre><code class="language-c" data-comment="">void master_thread() {
loop:
    for(int i = 0; i &lt; 10; i ++) {
        do_thing_once_per_second();
        sleep_1_second_if_necessary();
    }
    do_things_once_per_ten_sencods();
    goto loop;
}</code></pre>
<p>每秒一次地操作:</p>
<ul>
<li>日志缓冲刷新到磁盘,即使这个事务还没有提交(总是)</li>
<li>合并插入缓冲(可能)</li>
<li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘(可能)</li>
<li>如果当前当前没有用户活动,则切换到background loop(可能)</li>
</ul>
<pre><code class="language-c" data-comment="">void master_thread() {
    goto loop;
loop:
    for(int i = 0; i &lt; 10; i ++) {
        thread_sleep(1);
        do_log_buffer_flush_to_disk();
        if(last_one_second_ios &lt; 5) {
            do_merge_at_most_5_insert_buffer();
        }
        if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct) {
            do_buffer_pool_flush_100_dirty_page();
        }
        if(no_user_activity()) {
            goto background loop
        }
    }
    do_things_once_per_ten_seconds();
background loop:
    do_something();
    goto loop;
}</code></pre>
<p>每10秒的操作:</p>
<ul>
<li>刷新100个脏页到磁盘(可能的情况)</li>
<li>合并至多5个插入缓冲(总是)</li>
<li>将日志缓冲刷新到磁盘(总是)</li>
<li>删除无用的undo页(总是)</li>
<li>刷新100个或者10个脏页到磁盘(总是)</li>
</ul>
<pre><code class="language-c" data-comment="">void master_thread() {
    goto loop;
loop:
    for(int i = 0; i &lt; 10; i ++) {
        thread_sleep(1);
        do_log_buffer_flush_to_disk();
        if(last_one_secnod_ios &lt; 5) {
            do_merge_at_most_5_insert_buffer();
        }
        if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct) {
            do_buffer_pool_flush_100_dirty_page();
        }
        if(no_user_activity()) {
            goto background loop;
        }
    }
    if(last_ten_sencod_ios &lt; 200) {
        do_buffer_pool_flush_100_dirty_page();
    }
    do_merge_at_most_5_insert_buffer();
    do_log_buffer_flush_to_disk();
    do_full_purge();
    if(buf_get_modisied_ratio_pct &gt; 0.7) {
        do_buffer_pool_flush_100_dirty_page();
    }
    else {
        buffer_pool_flush_10_dirty_page();
    }
    goto loop
background loop:
    do_something();
    goto loop:
}</code></pre>
<p>background loop执行的操作:</p>
<ul>
<li>删除无用的undo页(总是)</li>
<li>合并20个插入缓冲(总是)</li>
<li>跳回主循环(总是)</li>
<li>不断刷新100个页直到符合条件(可能,跳转到Flush loop中完成)</li>
</ul>
<pre><code class="language-c" data-comment="">void master_thread() {
    goto loop;
loop:
    for(int i = 0; i &lt; 10; i ++) {
        thread_sleep(1);
        do_log_buffer_flush_to_disk();
        if(last_one_second_ios &lt; 5)
            do_merge_at_most_5_insert_buffer();
        if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct) 
            do_buffer_pool_flush_100_dirty_page();
        if(no_user_activity())
            goto background loop
    }
    if(last_ten_second_ios &lt; 200)
        do_buffer_pool_flush_100_dirty_page();
    do_merge_at_most_5_insert_buffer();
    do_log_buffer_flush_to_disk();
    do_full_purge();
    if(buf_get_modified_ratio_pct &gt; 0.7)
        do_buffer_pool_flush_100_dirty_page();
    else
        buffer_pool_flush_10_dirty_page();
    goto loop
background loop:
    do_full_purge();
    do_merge_20_insert_buffer();
    if not_idle:
        goto loop;
    else
        goto flush loop
flush loop:
    do_buffer_pool_flush_100_dirty_page();
    if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct) 
        goto flush loop;
    goto suspend loop;
suspend loop:
    supend_thread();
    waiting_event();
    goto loop;
}</code></pre>
<h3>2.5.2 InnoDB 1.2.x版本之前的Master Thread</h3>
<p>提供参数<code class="inline-code">innodb_io_capacity</code>,对于刷新到磁盘页的数量,会按照innodb_io_capacity的百分比
来进行控制</p>
<ul>
<li>在合并插入缓冲时,合并插入缓冲的数量为innodb_io_capacity的百分之五</li>
<li>在从缓冲区刷新脏页时,刷新脏页的数量为innodb_io_capacity</li>
</ul>
<p><code class="inline-code">innodb_max_dirty_pages_pct</code>调整到75,加快了刷新脏页的频率,保证了磁盘IO的负载</p>
<p><code class="inline-code">innodb_adaptive_flushing</code>(自适应的刷新),影响每秒刷新脏页的数量。</p>
<p><code class="inline-code">innodb_purge_batch_size</code>控制每次full purge回收undo页的数量</p>
<pre><code class="language-c" data-comment="">void master_thread() {
    goto loop;
loop:
    for(int i = 0; i &lt; 10; i ++) {
        thread_sleep(1)
        do_log_buffer_flush_to_disk();
        if(last_one_secode_ios &lt; 0.5 * innodb_io_capacity)
            do_merge_0.05_innodb_io_capacity_insert_buffer();
        if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)
            do_buffer_pool_flush_1_innodb_io_capacity_dirty_page();
        else if enable_adaptive_flush()
            do_buffer_pool_flush_desired_amount_dirty_page();
        if(no_user_activity())
            goto background loop
    }
    if(last_ten_sencod_ios &lt; innodb_io_capacity) 
        do_buffer_pool_flush_1_innodb_io_capacity_dirty_page();
    do_merget_0.05_innodb_io_capacity_insert_buffer();
    do_log_buffer_flush_to_disk();
    do_full_purge();
    if(buf_get_modified_ratio_pct &gt; 0.7)
        do_buffer_pool_flush_1_innodb_io_capacity_dirty_page();
    else
        do_buffer_pool_flush_0.1_innodb_io_capacity_dirty_page();
    goto loop
background loop:
    do_full_purge();
    do_merge_1_innodb_io_capacity_insert_buffer();
    if not_idle
        goto loop
    else
        goto flush loop
flush loop:
    do_buffer_pool_flush_1_innodb_io_capacity_dirty_page();
    if(buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct)
        goto flush loop;
        goto suspend loop;
suspend loop:
    suspend_thread();
    waiting_event();
    goto loop;
}</code></pre>
<h3>2.5.3 InnoDB 1.2.x版本的Master Thread</h3>
<pre><code class="language-c" data-comment="">if InnoDB is idle
    srv_master_do_idle_tasks() // 每10秒的操作
else
    srv_master_do_active_tasks() // 每秒的操作</code></pre>
<p>分离Page Cleaner Thread来操作刷新脏页</p>
<h2>2.6 InnoDB关键特性</h2>
<ul>
<li>插入缓冲</li>
<li>两次写</li>
<li>自适应哈希索引</li>
<li>异步IO</li>
<li>刷新邻接页</li>
</ul>
<h3>2.6.1 插入缓冲</h3>
<ol>
<li>Insert Buffer</li>
</ol>
<p>对于非聚集索引的插入和更新操作,不是每一次直接插入到索引页中,而是先判断插入的非聚集索引页
是否在缓冲池中,若在,则直接插入;若不在,则 先放到一个Insert Buffer对象中,好似欺骗。数据库这
个非聚集的索引已经插到叶子节点,而实际并没有,只是存放在另一个为位置。然后再以一定的频率和
情况进行Insert Buffer和辅助索引页子节点的merge操作,这时通常能将多个插入合并到一个操作
中(因为在一个索引页中),这就大大提高了对于非聚集索引的插入的性能。</p>
<p>Insert Buffer需要同时满足以下条件</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的</li>
</ul>
<ol start="2">
<li>Change Buffer</li>
</ol>
<p>InnoDB存储引擎对DML操作-insert、delete、update都进行缓冲,分别为insert buffer、
delete Buffer、purge buffer</p>
<p>Change Buffer适用的对象依然是非唯一的辅助索引</p>
<p>对一条记录的update操作可能分为两个过程</p>
<ul>
<li>将记录标记为已删除</li>
<li>真正将记录删除</li>
</ul>
<p><code class="inline-code">innodb_change_buffering</code>:开启各种buffer的选项</p>
<p><code class="inline-code">innodb_change_buffer_max_size</code>:控制Change Buffer最大使用内存的数量</p>
<ol start="3">
<li>Insert Buffer的内部实现</li>
</ol>
<p>Insert Buffer的数据结构是一棵B+树。</p>
<p>非叶子节点存放的是查询的search key</p>
<p>结构如下:</p>
<ul>
<li>space: 待插入记录所在表的表空间id</li>
<li>marker: 兼容老版本的Insert Buffer</li>
<li>offset: 表示页所在的偏移量</li>
</ul>
<ol start="4">
<li>Merge Insert Buffer</li>
</ol>
<p>Merge Insert Buffer的操作在以下几种情况下发生</p>
<ul>
<li>辅助索引页被读到缓冲池中</li>
<li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时</li>
<li>Master Thread</li>
</ul>
<h3>2.6.2 两次写</h3>
<p>doublewrite带给InnoDB存储引擎的是数据页的可靠性。</p>
<p>在应用重做日志前,用户需要一个页的副本,当写入失效发生时,先通过页的副本来还原该页,在进行重做,这就是两次写。</p>
<p>两次写有两部分组成</p>
<ul>
<li>内存的doublewrite buffer</li>
<li>物理磁盘上共享空间连续的128个页</li>
</ul>
<p>在对缓冲池的脏页进行刷新时,并不直接写磁盘,而是会通过memcpy函数将脏页先复制到内存的doublewrite buffer,
之后通过doublewrite buffer在分两次,每次1mb顺序地写入共享表空间的物理磁盘上,然后马上调用fsync函数,同步
磁盘,避免缓冲写带来的问题。</p>
<h3>2.6.3 自适应哈希</h3>
<p>InnoDB会监控对表上各索引页的查询,如果观察到建立哈希索引可以带来速度提升,则建立哈希索引,称之为自适应哈希索引。</p>
<h3>2.6.4 异步IO</h3>
<p>Sync IO: 每进行一次IO操作,需要等待此次操作结束才能继续接下来的操作</p>
<p>AIO: 用户可以在发出一个IO请求后立即再发一个IO请求,当全部IO请求发送完毕后,等待所有IO操作的完成</p>
<p>AIO的另一个优势是可以进行IO Merge操作</p>
<p>在InnoDB中,read ahead方式的读取都是通过AIO完成,脏页的刷新,即磁盘的写入操作则全部由AIO完成。</p>
<h3>2.6.5 刷新邻接页</h3>
<p>Flush Neighbor Page: 当刷新一个脏页时,InnoDB会检查该页所有区的所有页,如果是脏页,那么
一起进行刷新。</p>
<h2>2.7 启动、关闭与恢复</h2>
<p><code class="inline-code">innodb_fast_shutdown</code>:的值</p>
<ul>
<li>0 数据库关闭时,需要完成所有的full purge和merge insert Buffer,并且将所有的脏页刷新回磁盘</li>
<li>1 不需要完成full purge和Merge insert buffer,但是在缓冲池中的一些数据脏页还是会刷新回磁盘</li>
<li>2 不完成full purge和merge insert buffer,也不将缓冲池中的脏页刷新回磁盘,而是日志写入日志文件,
启动时进行恢复操作</li>
</ul>
<p><code class="inline-code">innodb_force_recovery</code>影响InnoDB恢复的状况</p>
<ul>
<li>0: 发生需要恢复时,进行所有恢复操作,恢复失败时,错误写入错误日志</li>
<li>1: 忽略检查到的corrupt页</li>
<li>2: 阻止Master Thread运行,</li>
<li>3: 不进行事务的回滚</li>
<li>4: 不进行插入缓冲的合并操作</li>
<li>5: 不查看撤销日志</li>
<li>6: 不进行前滚的操作</li>
</ul>
<h2>2.8 小结</h2>
<h6>2018.03.03</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>