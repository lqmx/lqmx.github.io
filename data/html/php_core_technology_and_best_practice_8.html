<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1518529416">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>PHP核心技术与最佳实践-第八章-缓存详解</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1518529416">
    <link rel="stylesheet" href="../../css/reset.css?v1518529416">
    <link rel="stylesheet" href="../../css/md.css?v1518529416">
    <link rel="stylesheet" href="../../css/module.css?v1518529416">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1518529416">
    <script src="../../dep/require.js?1518529416"></script>
</head>
<body>
<div class="md"><h1>8 缓存详解</h1>
<h6>20180208</h6>
<h2>8.1 认识缓存</h2>
<blockquote class="bq6">
<p>凡是位于速度相差较大的两种介质之间，用于协调两者数据传输速度差异的结构，
均可称为缓存</p>
</blockquote>
<p>一个网站或者应用的一般形式：</p>
<p>浏览器-&gt;应用服务器-&gt;数据存储层-&gt;应用服务器-&gt;浏览器</p>
<h3>8.1.1 为什么使用缓存</h3>
<ul>
<li>服务器资源有限</li>
<li>数据库并发量有限</li>
</ul>
<p>解决方法：减少计算量，缩短请求流程</p>
<p>理论上，每一层都可以被缓存</p>
<ol>
<li>底层： CPU缓存、磁盘文件系统缓存</li>
<li>应用层： Zend虚拟机变量缓存，有Memcached这样的Key Value内存缓存，有APC、eAccelerator
基于opcode字节码的缓存</li>
<li>数据库层： Table Cache、Thread Cache、Query Cache</li>
<li>Servlet容器层： Apache缓存</li>
<li>Web Cache层： Squid、Varnish</li>
<li>应用程序代码级别：Smarty文件缓存</li>
<li>HTTP：浏览器缓存</li>
</ol>
<p>缓存存放位置：内存和硬盘</p>
<p>缓存的三个要素：<code class="inline-code">命中率</code>,<code class="inline-code">缓存更新策略</code>,<code class="inline-code">缓存最大数据量</code></p>
<h3>8.1.2 命中率</h3>
<p>通常通过命中率衡量缓存机制的好坏和效率</p>
<p>如果数据更新频繁，就需要考虑缓存的合理性</p>
<h3>8.1.3 缓存更新策略</h3>
<ul>
<li>FIFO（First In First Out）：最先进入缓存的数据在缓存空间不够
情况下（超出最大元素限制）会被首先清理出去</li>
<li>LFU（Less Frequently Used）：最少使用的元素被清理</li>
<li>LRU（Least Recently Used）：最近最少使用的元素被清理</li>
</ul>
<h3>8.1.4 缓存最大数据量</h3>
<p>缓存最大数据量是在缓存中能处理元素的最大个数或所能使用的最大
存储空间</p>
<p>超过最大数据量：</p>
<ol>
<li>停止缓存服务，所有缓存数据被清空</li>
<li>拒绝写入，不在对缓存数据进行更新</li>
<li>根据缓存策略清除旧数据</li>
<li>在3的基础上，备份淘汰的数据，腾出新空间</li>
</ol>
<p>通常使用3，4</p>
<h2>8.2 文件缓存</h2>
<p>磁盘与内存相比更稳定更可靠，存储简单，扩展容易</p>
<h3>8.2.1 文件缓存机制</h3>
<p>动态PHP代码-&gt;静态HTML文件</p>
<p>有时，会把常用的或比较消耗数据库资源的大变量缓存起来</p>
<pre><code class="language-php" data-comment="">$data = $db-&gt;fetchAll($sql);
file_put_content(ROOT . 'cache/cat.php', var_export($data, true));

eval("\$data=$data;");</code></pre>
<h3>8.2.2 文件缓存开源产品Secache</h3>
<p>Secache是用PHP实现的Key Value数据库，把数据按照键值对方式存储到单文件中</p>
<h2>8.3 Opcode缓存</h2>
<p><code class="inline-code">Opcode缓存</code>就是虚拟机把PHPdiam编译成一种中间码的结果缓存起来</p>
<h3>8.3.1 eAccelerator下载及使用</h3>
<p>eAccelerator工具能够起到“常驻内存”的作用</p>
<h3>8.3.2 如何查看Opcode</h3>
<p>安装VLD扩展</p>
<h2>8.4 客户端缓存</h2>
<h3>8.4.1 客户端缓存规则</h3>
<ol>
<li>如果响应头信息告诉缓存器不要保留缓存，缓存器就不会缓存相应内容</li>
<li>如果请求信息需要认证或者安全加密，相应内容也不会被缓存</li>
<li>如果在回应中不存在校验器（ETag或者Last Modified头信息），缓存服务器会认为
缺乏直接的更新度信息，内容将会被认为不可缓存</li>
</ol>
<h3>8.4.2 HTTP协议中的缓存使用</h3>
<ol>
<li>Expires
<code class="inline-code">Expires</code>属性是HTTP控制缓存的基本手段，其告诉缓存器相关副本在多长时间内是可用的，
过了这段时间，缓存器就会向服务器发送请求，检测文档是否被修改</li>
</ol>
<p>HTTP的日期时间必须是格林威治时间（GMT）</p>
<ol start="2">
<li>
<p>Cache Control
<code class="inline-code">Cache Control</code>可让网站发布者全面控制内容，并定位过期时间的限制，有用的Cache Control
响应头信息包括<code class="inline-code">max-age=[second]</code>,<code class="inline-code">s-maxage=[secode]</code>,<code class="inline-code">public</code>,<code class="inline-code">no-cache</code>,<code class="inline-code">no store</code>,
<code class="inline-code">must-revalidate</code>,<code class="inline-code">proxy-pevalidate</code>
Last modified: 文档最后修改时间</p>
</li>
<li>ETag
服务器生成唯一标识符ETag，每次副本的标签都会变化</li>
</ol>
<ul>
<li>不经常改变的图片/页面启用缓存，使用Cache Control: max-age属性设置一个较长的国企时间</li>
<li>定期更新的内容设置一个缓存服务器可识别的max-age属性或过期时间</li>
<li>进来避免使用post，大部分缓存服务器保存</li>
<li>不要在url中加入针对每个用户的识别信息</li>
</ul>
<h3>8.4.3 HTTP缓存实例</h3>
<pre><code class="language-php" data-comment="">header('Cache-Control: max-age=84600, must-revalidate');
header('Last-Modified: '.gmdate('D,d M Y H:i:s').'GMT');
header('Expires: '.gmdate('D,d M Y H:i:s'.time()+' 80400').'GMT');</code></pre>
<h3>8.4.4 HTML5中的Application Cache</h3>
<p>优势：离线浏览、高速、更小的服务器负载</p>
<h2>8.5 Web服务器缓存</h2>
<h3>8.5.1 Apache缓存</h3>
<pre><code class="language-apacheconfig" data-comment="">ExpiresActive on
ExpiresByType image/gif "access plus 1 month"</code></pre>
<h3>8.5.2 nginx缓存</h3>
<pre><code class="language-nginx" data-comment="">location / {
    proxy_pass http://example.com;
    proxy_cache NAME;
    proxy_cache_valid 200 302 1h;
    proxy_cache_valid 310 1d;
    proxy_cache_valid any 1m;
}</code></pre>
<h2>8.6 本章小结</h2>
<p>缓存的原理，缓存的本质，缓存的目的</p>
<h6>20180208</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>