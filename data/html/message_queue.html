<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="update_time" content="1519482708">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>消息队列</title>
    <link rel="shortcut icon" type="images/x-icon" href="/favicon.png?v1519482708">
    <link rel="stylesheet" href="../../css/reset.css?v1519482708">
    <link rel="stylesheet" href="../../css/md.css?v1519482708">
    <link rel="stylesheet" href="../../css/module.css?v1519482708">
    <link rel="stylesheet" href="../../css/c.css?v1519482708">
    <link rel="stylesheet" href="../../dep/highlight/style/monokai_sublime.css?v1519482708">
    <script src="../../dep/require.js?1519482708"></script>
</head>
<body>
    <div class="md"><h1>消息队列</h1>
<h6>2018.02.23</h6>
<p>小红是小明的姐姐。</p>
<p>小红希望小明多读书，常寻找好书给小明看，之前的方式是这样：小红问小明什么时候有空，把书给小明送去，并亲眼监督小明读完书才走。久而久之，两人都觉得麻烦。</p>
<p>后来的方式改成了：小红对小明说「我放到书架上的书你都要看」，然后小红每次发现不错的书都放到书架上，小明则看到书架上有书就拿下来看。</p>
<p>书架就是一个消息队列，小红是生产者，小明是消费者。</p>
<h2>这带来的好处有：</h2>
<ol>
<li>小红想给小明书的时候，不必问小明什么时候有空，亲手把书交给他了，小红只把书放到书架上就行了。这样小红小明的时间都更自由。</li>
<li>小红相信小明的读书自觉和读书能力，不必亲眼观察小明的读书过程，小红只要做一个放书的动作，很节省时间。</li>
<li>当明天有另一个爱读书的小伙伴小强加入，小红仍旧只需要把书放到书架上，小明和小强从书架上取书即可（唔，姑且设定成多个人取一本书可以每人取走一本吧，可能是拷贝电子书或复印，暂不考虑版权问题）。</li>
<li>书架上的书放在那里，小明阅读速度快就早点看完，阅读速度慢就晚点看完，没关系，比起小红把书递给小明并监督小明读完的方式，小明的压力会小一些。</li>
</ol>
<h2>这就是消息队列的四大好处：</h2>
<ol>
<li>解耦
每个成员不必受其他成员影响，可以更独立自主，只通过一个简单的容器来联系。</li>
</ol>
<p>小红甚至可以不知道从书架上取书的是谁，小明也可以不知道往书架上放书的人是谁，在他们眼里，都只有书架，没有对方。</p>
<p>毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，小红小明可以自由自在地追求各自的人生。</p>
<ol start="2">
<li>提速
小红选择相信「把书放到书架上，别的我不问」，为自己节省了大量时间。</li>
</ol>
<p>小红很忙，只能抽出五分钟时间，但这时间足够把书放到书架上了。</p>
<ol start="3">
<li>
<p>广播
小红只需要劳动一次，就可以让多个小伙伴有书可读，这大大地节省了她的时间，也让新的小伙伴的加入成本很低。</p>
</li>
<li>削峰
假设小明读书很慢，如果采用小红每给一本书都监督小明读完的方式，小明有压力，小红也不耐烦。</li>
</ol>
<p>反正小红给书的频率也不稳定，如果今明两天连给了五本，之后隔三个月才又给一本，那小明只要在三个月内从书架上陆续取走五本书读完就行了，压力就不那么大了。</p>
<h2>当然，使用消息队列也有其成本：</h2>
<ol>
<li>
<p>引入复杂度
毫无疑问，「书架」这东西是多出来的，需要地方放它，还需要防盗。</p>
</li>
<li>暂时的不一致性
假如妈妈问小红「小明最近读了什么书」，在以前的方式里，小红因为亲眼监督小明读完书了，可以底气十足地告诉妈妈，但新的方式里，小红回答妈妈之后会心想「小明应该会很快看完吧……」</li>
</ol>
<p>这中间存在着一段「妈妈认为小明看了某书，而小明其实还没看」的时期，当然，小明最终的阅读状态与妈妈的认知会是一致的，这就是所谓的「最终一致性」。</p>
<h2>那么，该使用消息队列的情况需要满足什么条件呢？</h2>
<ol>
<li>生产者不需要从消费者处获得反馈
引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走——即所谓异步——成为了可能。</li>
</ol>
<p>小红放完书之后小明到底看了没有，小红根本不问，她默认他是看了，否则就只能用原来的方法监督到看完了。</p>
<ol start="2">
<li>容许短暂的不一致性
妈妈可能会发现「有时候据说小明看了某书，但事实上他还没看」，只要妈妈满意于「反正他最后看了就行」，异步处理就没问题。</li>
</ol>
<p>如果妈妈对这情况不能容忍，对小红大发雷霆，小红也就不敢用书架方式了。</p>
<ol start="3">
<li>确实是用了有效果
即解耦、提速、广播、削峰这些方面的收益，超过放置书架、监控书架这些成本。</li>
</ol>
<p>否则如果是盲目照搬，「听说老赵家买了书架，咱们家也买一个」，买回来却没什么用，只是让步骤变多了，还不如直接把书递给对方呢，那就不对了。</p>
<h2>参考</h2>
<p><a href="https://www.zhihu.com/question/34243607/answer/140732170">消息队列的使用场景是怎样的</a></p>
<h6>2018.02.24</h6></div>
<script >
    requirejs(['../../js/conf/r'], function(rc) {
        requirejs(['../js/html']);
    });
</script>
</body>
</html>