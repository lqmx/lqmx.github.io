# 最小字符串编辑距离

###### 2018.01.24

## 问题描述

>
    给定两个字符串m和n，只允许进行如下三种操作：
    + 插入，例如：ab -> abc
    + 删除，例如：abc -> ab
    + 替换，例如：abc -> abd
>    
    那么请求出将m变成n的最小操作次数（也就是最小编辑距离）

## 解法

```
if len(m) = 0
    d[j][k] = len(n)
elseif  len(n) = 0
    d[j][k] = len(m)
else
    if m[j] == n[k] 
        d[j][k] = d[j - 1][k - 1]
    else
        d[j][k] = min(d[j - 1][k] + 1, d[j][k - 1] + 1, d[j - 1][k - 1] + 1)
```

### 递归

```php
function editDistanceRecursion($m, $n, $j, $k) {
    if($k == 0) {
        return $j;
    } elseif($j == 0) {
        return $k;
    } elseif ($m[$j - 1] == $n[$k - 1]) {
        return editDistanceRecursion($m, $n, $j - 1, $k - 1);
    } else {
        $insert = editDistanceRecursion($m, $n, $j - 1, $k) + 1;
        $delete = editDistanceRecursion($m, $n, $j, $k - 1) + 1;
        $replace = editDistanceRecursion($m, $n, $j - 1, $k - 1) + 1;
        return min($insert, $delete, $replace);
    }
}
```

### 动态规划

```php
function editDistanceDynamic($m, $n) {
    $j = count($m);
    $k = count($n);
    $d = array();

    for($p = 0; $p <= $j; $p ++) {
        $d[$p] = array();
        $d[$p][0] = $p;
    }
    for($q = 0; $q <= $k; $q ++) {
        $d[0][] = $q;
    }
    for($p = 1; $p <= $j; $p ++) {
        for($q = 1; $q <= $k; $q ++) {
            if($m[$p - 1] == $n[$q - 1]) {
                $d[$p][$q] = $d[$p -1][$q -1];
            } else {
                $insert = $d[$p - 1][$q] + 1;
                $delete = $d[$p][$q - 1] + 1;
                $replace = $d[$p - 1][$q - 1] + 1;
                $d[$p][$q] = min($insert, $delete, $replace);
            }
        }
    }
    return $d[$j][$k];
}
```

### 测试

```php
$ms = 'lmxqmx';
$ns = 'lqmx';

$m = str_split($ms);
$n = str_split($ns);
$j = count($m);
$k = count($n);

echo editDistanceRecursion($m, $n, $j, $k), PHP_EOL;
echo editDistanceDynamic($m, $n), PHP_EOL;
```

## 参考

[最小编辑距离问题](http://blog.csdn.net/jinboker/article/details/78405881?locationNum=3&fps=1)

###### 2018.01.24