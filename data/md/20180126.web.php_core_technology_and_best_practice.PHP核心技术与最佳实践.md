# PHP Core Technology and Best Practice

###### 2018.01.26

PHP 核心技术与最佳实践




## 第三章 正则表达式基础与应用

### 3.1 认识正则表达式

> 正则表达式就是用某种模式去匹配一类字符串的一种公式

#### 3.1.1 PHP中的正则函数

正则表达式的实现有多种引擎，其表现又有多种风格

PHP中有两套正则函数
1. 由PCRE库提供的函数，以“preg_”为前缀命名
2. 由POSIX扩展提供的函数，以“ereg_”为前缀命名

#### 3.1.2 正则表达式的组成

在PHP中，一个正则表达式分为三个部分：`分隔符`、`表达式`和`修饰符`

分隔符：可以是除了字母、数字、反斜杠和空白字符以外的任何字符（比如/、!、#、%、|、-等）
表达式：由一些特殊字符和非特殊的字符串组成
修饰符：用于开启或者关闭某种功能/模式

#### 3.1.3 测试工具的使用

### 3.2 正则表达是中的元字符

"\b" 表示单词的分界处（前一个字符和后一个字符不全是"\w")

#### 3.2.1 什么是元字符

元字符是正则表达式中具有特殊意义的专用字符，用来规定前导字符

#### 3.2.2 起始和结束元字符

^：匹配字符串的开始
$： 匹配字符串的结束

#### 3.2.3 点号

. 匹配全部字符

#### 3.2.4 量词

/+ 一个或多个
? 0个或一个
/* 0个或多个
{m,n} m~n个

### 3.3 正则表达式匹配规则

#### 3.3.1 字符组

[] 匹配单个字符，如[aeiou]
[] 指定字符范围，如[a-z0-9A-Z_]

#### 3.3.2 转义

在PHP中使用反斜杠（\)表示转义，\Q和\E也可以在模式中忽略正则表达式元字符

值得注意的例子：
`[aby\}]`、`c[oua?*]t`、`c[\d]d`、`、\(?0\d{2}[) -]?\d[8]`

#### 3.3.3 反义

反义有一个比较明显的特征，就是和一些已知元字符相反，并且为大写形式
^表示开始位置时在正则表达式最前端，表示取反只在中括号中出现

#### 3.3.4 分支

分支就是存在多种匹配的情况
"|" 表示分支
匹配分支条件时，短路规则

#### 3.3.5 分组

`(\d{1,3}\.){3}`

#### 3.3.6 反向引用

反向引用用于重复搜索前面某个分组匹配的文本
匹配重复单词：`\b(\w+)\b\s+\1\b`, `\b(?<Word>\w+)\b\s+\k<Word>\b`
匹配引号内字符 "\"this is a 'string'\"": `("|\').*?\1`

应用：ubb
```php
$str = '[url]1.gif[/url][url]2.gif[/url][url]3.gif[/url]';
$s = preg_replace("#\[url\](?<WORD>\d\.gif)\[\/url\]#", "<img src=http://image.ai.com/upload/$1>", $str);
var_dump($s);

$s = preg_replace("#\[url\](.*?)\[\/url\]#", "<img src=http://image.ai.com/upload/$1>", $str);
var_dump($s);
```

#### 3.3.7 环视

`零宽断言`: 用户查找在某些内容（当不包括这些内容）之前或之后，也就是一个位置（如\b、
^）应该满足的一定条件（即断言）

+ 顺序肯定环视(?=exp)
> 零宽度正预测先行断言，又称顺序肯定环视，断言自身出现位置的后面能匹配表达式exp

匹配以“ing”结尾的单词前面部分（除了“ing”以外的部分）`\b\w+(?=ing\b)`

+ 逆序肯定环视(?<=exp)
> 零宽度正回顾后发断言，又称逆序肯定环视，断言自身出现位置的前面能匹配表达式exp

匹配以re开头的单词的后半部分`(?<=\bre)\w+\b`

其他：`\b\w\*q(?<=u)\w\*\b`

+ 顺序否定环视(?!exp)
> 零宽度负预测先行断言，又称顺序否定环视，断言此位置的后面不能匹配表达式exp

匹配3位数字，而且这3为数字后面不能是数字`\d{3}(?!\d)`
匹配不包含连续字符串abc的单词`\b((?!abc)\w)+\b`
匹配单词开头是c，t结尾，中间不包含u或a`c(?![au]t\b)\w+t`
匹配文本中都不能出现字符串‘cat’`^(?:(?!cat).)+$`

+ 逆序否定环视(?<!exp)
> 零宽度负回顾后发断言，又称逆序否定环视，可以用（?<!exp）断言此位置的前面不能匹配表达式exp

前面不是小写字母的7位数字`(?<![a-z])\d{7}`
匹配不包含属性的简单HTML标签内的内容`(?<=<(\w+)>).*(?=<\/\1>)`

#### 3.3.8 贪婪/懒惰匹配模式

懒惰模式匹配的原理是在匹配和不匹配都可以的情况下，优先不匹配，记录备选状态，
并将匹配控制交给正则表达式的下一个匹配字符，当后面的匹配失败时，回溯，进行匹配。

最先开始匹配拥有最高优先权

懒惰限定符
+ *? 重复任意次，但尽可能少重复
+ +? 重复1次或多次，但尽可能少重复
+ ?? 重复0次或1次，但尽可能少重复
+ {n,m}? 重复n到m次，但尽可能少重复
+ {n,}? 重复n次以上，但尽可能少重复

### 3.4 构造正则表达式

#### 3.4.1 正则表达式的逻辑关系

正则表达式之间的逻辑关系可以简单地用与或非来描述
1. 与
`abc`,`\w+(?=ing)`,`(?<=<div>).*(?=</div>)`
2. 或
`?a??`,`[(ab)+]`,`[abc]`,`f(oo|ee)t`
3. 非
`[^"]*`,`<a[^>]*>.*<\/a>`,`<(?!/?p\b)[^>]+>`

#### 3.4.2 运算符优先级

    转义符(\)>括号和中括号（(),(?:),(?=),[])>限定符(*,+,?,{n},{n,m})>替换(|)

#### 3.4.3 正则表达式的常用模式

模式就是可以改变表达行为的字符，用来关闭或打开某些特殊功能，习惯上又称正则修饰符。

1. 忽略大小写模式 i
2. 多行模式 m
"this is reg\nReg\this is\nregexp turtor, oh reg" => `/.*reg$/mi`, `/^t.*/mi`
3. 点号通配模式 s
点号通配模式的作用是试用正则表达式里的点号元字符可以匹配换行符，如果没有这个修饰符，点号
不匹配换行符
4. 懒惰模式 u
5. 结尾限制 D
如果使用限制结尾字符，则不允许结尾有换行
6. 支持UTF-8转义表达 u

### 3.5 正则在实际开发中的应用

#### 3.5.1 移动手机校验 `1[3589]\d{9}`

#### 3.5.2 匹配E-mail地址 `\w{3,16}@\w{1,64}\.\w{2,5}`

#### 3.5.3 转义在数据安全中的应用

#### 3.5.4 URL重写于搜索引擎优化

使用URL重写的好处
1. 有利于搜索引擎的抓取
2. 用户更容易记忆
3. 隐藏实现技术

#### 3.5.5 删除文件中的空行和注释

### 3.6 正则表达式的效率与优化

1. 使用字符组代替分支条件
2. 优先选择最左端的匹配结果
3. 标准量词是匹配优先的
4. 谨慎用点号元字符,尽可能不用星号和加号这样的任意量词
5. 尽量使用字符串函数处理代替
6. 合理使用括号
7. 起始、行描点优化
8. 量词等价转换的效率差异
9. 对大而全的表达式进行拆分
10. 使用正则以外的解决方案
PHP的字符串函数:
PHP的Tokenizer系列函数
PHP的url函数及一些http函数
PHP的filter系列函数
JavaScript的DOM模型

### 3.7 本章小结

## 第四章 PHP网络技术及应用

### 4.1 HTTP协议详解

HTTP是一个基于应用层的通信规范

#### 4.1.1 HTTP协议与SPDY协议

HTTP是一个应用层协议,由请求和响应构成,是一个标准的客户端服务器模型。

HTTP协议是一个无状态的协议,同一个客户端的两个请求没有对应关系。

SPDY协议是Google推出的协议,优化了浏览器和服务器之间的通信

+ 支持流复用
+ 具备优先级的请求
+ 主动发起请求
+ 强制SSL安全传输

SPDY协议的应用需要客户端和服务器同时支持

#### 4.1.2 HTTP协议如何工作

一次HTTP操作称为一个事务

1. 客户端与服务器建立连接
2. 客户端发送一个请求给服务器(URL+协议版本号+MIME信息)
3. 服务器接到请求,给予响应(状态行+MIME信息)
4. 客户端与服务器断开连接

协议中的一些概念

1. 请求

HTTP请求由三个部分组成:`请求行`,`消息报头`,`请求正文`

请求行: Method(请求方法) Request-URL(统一资源标识符) HTTP-Version(HTTP协议版本) CRLF(回车和换行)

请求方法如下:

+ GET 请求获取Request URL所标识的资源
+ POST 在Request URL所标识的资源后面附加新的数据
+ HEAD 请求获取由Request URL所标识的资源的响应消息报头
+ PUT 请求服务器存储一个资源,并用Request URL作为其标识
+ DELETE 请求服务器删除Request URL所标识的资源
+ TRACE 请求服务器回送收到的请求消息,主要用于测试或诊断
+ CONNECT 保留以备将来使用
+ OPTIONS 请求查询服务器的性能,或者查询与资源相关的选项和需求

2. 响应

HTTP响应也由三个部分组成:`状态行`,`消息报头`,`响应正文`

状态行: HTTP-Version(HTTP协议版本) Status-Code(服务器返回的响应状态代码) Reason-Phrase(状态代码的文本描述) CRLF(回车和换行)

状态代码:

+ 1xx: 指示消息-请求已接收,继续处理
+ 2xx: 成功-请求已被成功接收、理解、接受
+ 3xx: 重定向-要完成请求必须进一步的操作
+ 4xx: 客户端错误-请求有语法错误或请求无法实现
+ 5xx: 服务端错误-服务端未能实现合法的请求

常见的状态码:

+ 200 OK 客户端请求成功
+ 400 Bad Request 客户端请求有语法错误,不能被服务端理解
+ 401 Unauthorized 请求未经授权
+ 403 Forbidden 服务器收到请求,但是拒绝提供服务
+ 404 Not Found 请求资源不存在
+ 500 Internal Server Error 服务器发生不可预期的错误
+ 503 Server Unavailable 服务器当前不能处理客户端的请求,一段时间后可能恢复正常
 
3. 报头

HTTP消息报头包括`普通报头`,`请求报头`,`响应报头`,`实体报头`

报头的格式: 名字+: +空格+值

消息报头域的名字不区分英文大小写

+ 普通报头中有少数报头域用户所有的请求和响应消息,但不用于被传输的实体,只用于传输的消息
(如缓存控制、连接控制等)
+ 请求报头允许客户端向服务器传递请求的附加消息以及客户端自身的信息(如UA头、Accept等)
+ 响应报头允许服务器传递不能放在状态行中的附加响应信息,以及关于服务器的消息和对Request
URL所标志的资源进行下一步的访问的消息(如Location)
+ 实体报头定义了关于实体正文和请求所标志的资源的元信息,例如有无实体正文

比较重要的报头:

+ Host 头域指定请求资源的Internet主机和端口号
+ User Agent 包含发出请求的用户信息(不仅使用浏览器才存在,只要使用了基于HTTP协议的客户端
软件都会发送这个请求)
+ Cookie 
    - 客户端向服务端发送的,使用Cookie报头(value里可以有多个Cookie值,不需要显式指定domain等)
    - 服务端发送给浏览器的,报头为Set Cookie(只能有一个Cookie的value,需要指定domain、path等)
+ Cache Control 指定请求和响应遵循的缓存机制
+ Referer 头域允许客户端指定请求URI的源资源地址,这个可以允许服务器生成回退链表,用来
登录、优化缓存等。Referer通常是流量统计系统中用来记录来访者地址的参数
+ Content Length 内容长度
+ Content Range 响应的资源范围,可以实现断点续传
+ Accept Encoding 指定所能接受的编码方式
+ 自定义报头

#### 4.1.3 HTTP应用:灌水机器人

1. 浏览器的工作流程
浏览器就是一个实现了HTTP协议的客户端软件
2. PHP中和HTTP相关的函数
`get_headers(string URL [, intformat])`: 取得服务器响应一个http请求所发送的所有报头。
`fopen`, `file_get_contents`: 可以用来操作文件,也可以请求一个网络上的资源。
`stream_*`: 发送请求,包括但不限于http协议
`socket`系列函数: 统考socket发送和请求数据,包括但不限于http协议
`cURL`扩展库: 可以用来模拟浏览器和服务器进行交互,功能比较强大
`header`函数: PHP中可用此函数发送原始的http头。

```php
<?php
$html = file_get_contents('http://www.baidu.com');
print_r($http_response_header);
$fp = fopen('http://www.baidu.com', 'r');
$result = stream_get_meta_data($fp);
print_r($result);
fclose($fp);
```
3. 模拟灌水机器人
```php
$data = array(
    'author' => 'l',
    'mail' => 'info@aiyooyoo.com',
    'text' => '..',
);
$data = http_build_query($data);
$opts = array(
    'method' => 'POST',
    'header' => "Content-type: application/x-www-form-urlencode\r\n".
        "Content-Length: ".strlen($data)."\r\n". 
        "Cookie: PHPSESSID=131aofdiu232\r\n".
        "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36".
        "Referen: www.baidu.com\r\n",
    'content' => $data,
);
$context = stream_context_create($opts);
$html = @file_get_contents('http://aiyooyoo.com/index.php/archives/comment', false, $context);
```

#### 4.1.4 垃圾信息防御措施

1. IP限制
2. 验证码
3. Token和表单欺骗
4. 审核机制

```php
<?php
// token法
define('SECRET', '67%$&ap28');
function m_token() {
	$str = mt_rand(1000, 9999);
	$str2 = dechex($_SERVER['REQUEST_TIME']-$str);
	return $str.substr(md5($str.SECRET), 0, 10).$str2;
}
echo m_token();
echo '<br/>';
function v_token($str, $delay = 300){
	$rs = substr($str, 0, 4);
	$middle = substr($str, 0, 14);
	$rs2 = substr($str, 14, 8);
	return ($middle == $rs.substr(md5($rs.SECRET), 0, 10)) && ($_SERVER['REQUEST_TIME']-hexdec($rs2)-$rs < $delay);
}
var_dump(v_token(m_token()));
```

### 4.2 抓包工具

#### 4.2.1 抓包工具分类

常规抓包工具: `IRIS`,`Wireshark`
专用抓包工具: `HttpWatch`, `Fiddler`, `IE Analyzer`, `Charles`

#### 4.2.2 Fiddler功能与原理

Fiddler是用一款http/https网络调试器,以代理服务器的方式监听系统的网络数据流动。
其工作原理是在浏览器(或者其他使用http协议的进程)和服务器之间扮演代理的角色,
这样所有的通信都要结果它。

#### 4.2.3 安装Fiddler

#### 4.2.4 Fiddler基本页面

#### 4.2.5 使用Fiddler进行HTTP断点调试

### 4.3 Socket进程通信机制及应用

`socket`通常称为套接字,用于描述ip地址和端口,是一个通信链的句柄。
应用程序通过套接字向网络发出请求或者应答网络请求。
socket既不是一个程序,也不是一种协议,其只是操作系统提过的通信层的一组抽象API。

#### 4.3.1 进程通信相关概念

本机进程之间的通信:

1. UNIX BSD中的管道
2. 命名管道
3. 软中断信号
4. UNIX System V的消息
5. 共享存储器
6. 信号量

为解决网间进程通信,TPC/IP协议引入了以下概念

1. 端口
网络中可以被命名和寻址的通信端口,是操作系统可分配的一种资源
端口是一种抽象的软件结构(包括一些数据结构和I/O缓冲区)
由于TCP/IP传输层的TCP协议和UDP协议是完全独立的两个软件模块,
因此各自的端口号也相应独立,如TCP有255个端口,UDP也有,二者并不冲突

2. 地址
网络通信中通信的两个进程分别处在不同的机器上,遵循以下原则

+ 某台主机可与多个网络相连,必须指定一个特定网络地址
+ 网络上每台主机应有其唯一的地址
+ 每台主机上的每个进程应有在该主机上的唯一标识符

3. 连接
两个进程间的通信链路称为连接。连接表现为一些缓冲区和一组协议机制

#### 4.3.2 Socket演示:实现服务器端与客户端的交互

```php
<?php
$sock = fsockopen('192.168.0.2', 8001, $errno, $errstr, 1);
if(!sock) {
	echo $errstr($errno), PHP_EOL;
}
else {
	socket_set_blocking($sock, false);
	fwrite($sock, "send data...\r\n");
	fwrite($sock, "end\r\n");
	while(!feof($sock)) {
		echo fread($sock, 128);
		flush();
		ob_flush();
		sleep(1);
	}
	fclose($sock);
}
```

#### 4.3.3. socket函数原型

```c
SOCKET socket(int af, int type, int protocol);

```

socket从传输模式上又可以分为端对端和点对点的连接,流套接字和数据报套接字都属于端对端
的连接,因此需要绑定端口号。而原始套接字是基于IP协议的,属于点对点的传输模式,是没有端口
这个概念的(如ping)。

#### 4.3.4 PHP中的socket函数

```php
// 创建一个socket
resource socket_create(int $domain, int $type, int $protocol);
// 将ip地址和端口绑定到socket_create函数创建的句柄中
bool socket_bind(resource $socket, string $address[, int $port=0]);
// 监听客户端数据
bool socket_listen(resource $socket[, int $backlog=0]);
// 设置为非阻塞模式
bool socket_set_block(resource $socket);
// 向socket写入数据
int socket_write(resource $socket, string $buffer[, int $length=0])
// 从socket中读取指定长度的数据
string socket_read(resource $socket, int $length[, int $type=PHP_BINARY_READ])
// 实现长连接
pfsocketopen(string $hostname[, int $port=-1[,int& $errno[,  string& $errstr[, float $timeout=ini_get('default_socket_timeout')]]]]);
// 设置socket的控制选项
bool socket_set_option(resource $socket, int $level, int $optname, mixed $optval);
// 返回操作中任何socket函数产生的最后错误
int socket_last_error([resource $socket]);
```
```php
$host = "127.0.0.1";
$port = 12345;
set_time_limit(0);
$socket = socket_create(AF_INET, SOCK_STREAM, 0) or die("Could not create this socket\n");
$result = socket_bind($socket, $host, $port) or die("Could not bind to socket\n");
$result = socket_listen($socket, 3) or die("Could not set up listener\n");
$spawn = socket_accept($socket) or die("Could not accept incoming connection\n");
$input = socket_read($spawn, 1024) or die("Could not read input \n");
$input = trim($input);
$output = strrev($input)."\n";
socket_write($spawn, $output, strlen($output)) or die ("Could not write output\n");
socket_close($spawn);
socket_close($socket);
```

#### 4.3.5 socket交互应用:使用socket抓取数据

```php
$post = array(
    'author' => '..',
    'mail' => 'wait@qq.com',
    'url' => '',
    'text' => '',
);
$data = http_build_query($post);
$fp = fsockopen('typeecho.org', 80, $errno, $errstr, 5);
$out = "POST http://typecho.org/archives/comment HTTP/1.1\r\n";
$out .= "$data\r\n\r\n";
fwrite($fp, $out);
while (!feof($fp)) {
    echo fgets($fp, 1280);
}
fclose($fp);
```

### 4.4 cURL工具及应用

#### 4.4.1 建立cURL请求的基本步骤

1. 初始化
2. 设置选项
3. 执行并获取HTML文档内容
4. 释放cURL句柄

```php
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://www.php.net');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CUROOPT_HEADER, 1);
$output = curl_exec($ch);
curl_close($ch);
```

#### 4.4.2 检查cURL错误和获取返回信息

```php
@header('Content-type:image/png');
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://renren.com/usr/uploads/2011/06/3230341841.png');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
$output = curl_exec($ch);
$info = curl_getinfo($ch);
curl_close($ch);
file_put_contents('./a.png', $output);
$size = filesize('./a.png');
if($size!=$info['size_download']) {
	echo 'error', PHP_EOL;
}
else {
	echo 'done', PHP_EOL;
}
```

#### 4.4.3 在cURL中伪造头信息

```php
@header('Content-type:text/html;charset=utf-8');
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, 'http://3g.qq.com');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
$h = array(
	'HTTP_VIA:HTTP/1.1 SNXA-PS-WAP-GW21(infoX-WISG, HuaweiTechnologies)',
	'HTTP_ACCEPT:applicatioin/vnd.wap.wmlscript, text/vnd.wap.wml, application/vnd.wap.html+xml, application/xhtml+xml, text/html, multipart/mixed, */*',
);
curl_setopt($ch, CURLOPT_HTTPHEADER, $h);
$output = curl_exec($ch);
curl_close($ch);
```

#### 4.4.4 在cURL中用POST方法发送数据

```php
$url = "http://localhost/post_output.php";
$data = array(
    'foo' => 'bar',
);
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
$output = curl_exec($ch);
curl_close($ch);
echo $output;
```


#### 4.4.5 使用cURL上传文件

```php
$url = "http://localhost/post_output.php";
$data = array(
    'foo' => 'bar',
    'upload' => '@test.zip',
);
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
$output = curl_exec($ch);
curl_close($ch);
echo $output;
```

#### 4.4.6 cURL批处理

```php
$ch1 = curl_init();
$ch2 = curl_init();
curl_setopt($ch1, CURLOPT_URL, "http://a.php.net");
curl_setopt($ch2, CURLOPT_URL, "http://b.php.net");
$mh = curl_multi_init();
curl_multi_add_handle($mh, $ch1);
curl_multi_add_handle($mh, $ch2);
$active = null;
do {
    $mrc = curl_multi_exec($mh, $active);
} while($mrc == CURLM_CALL_MULTI_PERFORM);
while ($active && $mrc == CURLM_OK) {
    if(curl_multi_select($mh) != -1) {
        do {
            $mrc = curl_multi_exec($mh, $active);
        }while($mrc == CURLM_CALL_MULTI_PERFORM);
    } 
}
curl_multi_remove_handle($mh, $ch1);
curl_multi_remove_handle($mh, $ch2);
curl_multi_close($mh);
```
这种方式并不是多线程,它属于异步处理的范畴

#### 4.4.7 cURL设置项

`curl_setopt`, `curl_setopt_array`

#### 4.4.8 网络应用:使用cURL抓取腾讯微博

1. 分析抓包数据
2. 登录页面的处理

### 4.5 简单邮件传输协议SMTP

要想使用SMTP协议发送邮件,需要安装SMTP服务器或使用socket链接一个已有的服务器,用其发送邮件

#### 4.5.1 SMTP协议如何工作

SMTP是由源地址到目的地址传送邮件的一组规则,用来控制信件的中转方式

SMTP协议属于TCP/IP协议族

连接和发送的过程如下

1. 建立TCP连接
2. 客户端发送HELO命令以标识发送人自己的身份,客户端发送MAIL命令。服务器以OK作为响应,表明准备接收
3. 使用AUTH命令登录SMTP服务器,输入用户名和密码
4. 客户端发送RCPT命令,标识该邮件的计划接收人,可以有多个RCPT行。服务器以OK作为响应,表示愿意
为收件人发送邮件
5. 协商结束后,使用DATA命令发送
6. 以.号表示结束,输入内容一起发送出去,结束此次发送,用QUIT命令退出

#### 4.5.2 SMTP常用命令

`DATA`, `EXPN`, `HELO`, `HELP`, `MAIL FROM`, `NOOP`, `QUIT`, `RCPT TO`,
`RSET`, `SAML FROM`, `SEND FROM`, `SOML FROM`, `TURN`, `VRFY`,


#### 4.5.3 SMTP协议应用: 使用Socket发送邮件

```php
class SMTP {
    
    private $host;
    private $port = 25;
    private $user;
    private $pass;
    private $debug = false;
    private $sock;
    private $mail_format = 0;
    
    function smtp_mail($host, $port, $user, $pass, $format = 1, $debug = 0) {
        $this->host = $host;
        $this->port = $port;
        $this->user = $user;
        $this->pass = $pass;
        $this->mail_format = $format;
        $this->debug = $debug;
        $this->sock = fsockopen($this->host, $this->port, &$errno, &$errstr, 0);
        if(!$this->sock) {
            exit("Error number: $errno, Error message: $errstr\n");
        }
        $response = fgets($this->sock);
        if(strstr($response, "220") === false) {
            exit ("server error: $response\n");
        }
    }
    
    function show_debug($message) {
        if($this->debug) {
            echo "<p>Debug $message</p>\n";
        }
    }
    
    function do_command($cmd, $return_code) {
        fwrite($this->sock, $cmd);
        $response = fgets($this->sock);
        if(strstr($response, "$return_code") === false) {
            return false;
        }
        return true;
    }
    
    function is_email($email) {
        $pattern = "/^[^_][\w]*@[\w.]+[\w]*[^_]$/";
        if(preg_match($pattern, $email, $matches)) {
            return true;
        }
        return false;
    }
    
    function send_email($from, $to, $subject, $body) {
        if(!$this->is_email($from) or !$this->is_email($to)) {
            $this->show_debug("Please enter vaild from/to email");
            return false;
        }
        if(empty($subject) or empty($body)) {
            $this->show_debug("Please enter subject/content");
            return false;
        }
        $detail = "From: $from\r\n";
        $detail .= "To: $to\r\n";
        if($this->mail_format == 1) {
            $detail .= "Content-Type: text/html;\r\n";
        } else {
            $detail .= "Content-Type: text/plain;\r\n";
        }
        $detail .= "charset=gb2312\r\n\r\n";
        $detail .= $body;
        $this->do_command("HELO smtp.qq.com\r\n", 250);
        $this->do_command("AUTH LOGIN\r\n", 334);
        $this->do_command($this->user."\r\n", 334);
        $this->do_command($this->pass."\r\n", 235);
        $this->do_command("MAIL FROM:$from\r\n", 250);
        $this->do_command("RCPT TO: $to\r\n", 250);
        $this->do_command("DATA\r\n", 354);
        $this->do_command("$detail\r\n.\r\n", 250);
        $this->do_command("QUIT\r\n", 221);
        return true;
    }
}
```

### 4.6 WebService的前世今生

#### 4.6.1 WebService简介

广义的Webservice可以实现硬件和软件,硬件和硬件,软件和软件之间的通信

#### 4.6.2 认识PHPRPC协议

PHPRPC是一个轻型的,安全的,跨国际的,跨语言的,跨平台的,跨环境的,跨域的协议,支持复杂
对象传输,引用参数传输,内容输出重定向,分级错误处理,会话,是面向服务的高性能远程调用协议

#### 4.6.3 Web服务的实现模式

PHP支持两中Web服务模式:`WSDL`和`non WSDL`

Web服务主要有两种实现模式:`契约先行模式`,`代码先行模式`

契约先行模式的实现中,首要工作是定义正对这个Web服务接口的WSDL文件,契约订立之后,再据此
进行服务器端和客户端应用程序的开发
[WSDL文件详细介绍](http:www.w3cshool.com.cn/swdl)

代码先行模式,第一步工作是实现Web服务端,根据服务端的实现,用某种方法(自动生成或手工编写)
生成WSDL文件

#### 4.6.4 简单对象访问协议SOAP

`SOAP`是基于XML的,可扩展的通信协议
SOAP具有可扩展性和平台无关性

#### 4.6.5 调试工具soapUI

[下载链接](http://www.soapui.org)

### 4.7 Cookie详解

#### 4.7.1 Cookie的基本概念及设置

`Cookie`是存储在客户端的一小段数据,浏览器通过HTTP协议和服务器端景象Cookie交互
Cookie是由浏览器实现和管理的,Cookie和PHP没有任何关系,只和浏览器相关,PHP只负责和客户
端打招呼,具体管理由客户端全程完成

```php
bool setcookie(string $name[,string $value[, int $expire=0[, string $path[, string $domain[, $secure=false], bool $httponly=false]]]]]])
``` 

由PHP在当前页设置的Cookie并不能立即生效,要等到下一个页面才能看到。
Cookie没有显式删除函数,但是可以设置过期时间

#### 4.7.2 PHP和JavaScript对Cookie的操作

```php
setcookie('vote', 'k100', time_3600);
print_r($_COOKIE];
```


#### 4.7.3 Cookie存储机制及应用

每个域名下允许的Cookie数量是有限制的
每个Cookie最大字节数也是有限制的
Cookie会增加带宽

#### 4.7.4 Cookie跨域与P3P协议

正常的Cookie只能在一个应用中共享,即一个Cookie只能由创建它的应用获得。
实现Cookie的跨域,主要是为了统一应用平台,即实现单点登录

P3P协议由万维网协会研制,为Web用户提供了对自己公开信息的更多控制。

Cookie跨域设计两个不同的应用,习惯上称为第一方和第三方
第一方Cookie来自正在查看的网站,或者发送到目前正在查看的网站
第三方Cookie来自当前正在查看的网站以外的网站,或者发送到当前正在查看的网站以外的网站


步骤

1. 在host文件添加测试域名 
127.0.0.1 www.atest.com 
127.0.0.1 www.btest.com
2. 访问www.atest.com时调用www.btest.com的页面,种下Cookie
```js
<script src="http://www.btest.com/t/get.php?id=1000><script>
```
```php
header('P3P:Cp="CURa ADMa-dEVa PSAo ....."');
setcookie('p3p', $_GET['id'], time()+3600, "/", ".btest.com");
```
```php
var_dump($_COOKIE);
```

#### 4.7.5 本地存储localStorage

HTML5本地存储只能存储字符串,任何格式存储的时候都会被自动转为字符串

### 4.8 Session详解

`Session`即会话,指一种持续的、双向的连接   
                
#### 4.8.1 Session的基本概念及设置

Session指用户在浏览某个网站时,从进入网站到浏览器光比这段时间内的会话

#### 4.8.4 Session工作原理

Session通过一个称为PHPSESSID的Cookie和服务器联系,Session是通过SessionID
判断客户端用户的,即Session文件的文件名
Session以文件的形式存放在本地硬盘的一个目录中,所以Session比较多时,磁盘读取文件就会比较慢
对于设置分级目录存储的Session,PHP不会自动回收,需要自己实现其回收机制

#### 4.8.3 Session入库

```php
bool session_set_save_handler(callback open, callback close, callback read, callback write, callback destroy, callback gc)
```

在大流量的网站中,Session入库存在效率不高,占数据库connection资源等问题。
针对这种情况,可以使用Memcached、Redis等key value数据存储方案实现高并发
大流量的Session存储。

#### 4.8.4 Cookie与Session问答

1. Cookie运行在客户端,Session运行在服务端,对吗
不完全正确,Cookie是运行在客户端,由客户端进行管理;
Session虽然运行在服务端,但是SessionID作为一个Cookie存储在客户端

2. 浏览器禁止Cookie,Cookie就不能用了,但Session不会受浏览器影响,对吗
错。浏览器禁止Cookie,Cookie确实不能用了,Session会受浏览器的影响

3. 浏览器关闭后,Cookie和Session都消失了对吗
错。存储在内存中的Cookie会随着浏览器的关闭而消失,但存储在硬盘上的不会,
Session在浏览器关闭后不会消失,除非正常退出,代码显式删除Session

4. Session比Cookie更安全吗,不应该大量使用Cookie吗
错,通常情况下,Cookie和Session是绑定的,获得Cookie就相当于获取了Session,
不存在Session比Cookie更安全的说法

5. Session创建在服务器上,应该少用Session而多用Cookie对吗
错,Cookie可以提高用户体验,但会加大网络之间的数据传输量

6. 如果别人把Cookie复制到我电脑上,是不是能够登录别人的账号
是,要避免这种情况,需要在Cookie中针对ip、ua等加上特殊校验信息,然后和服务器端比对

7. 在ie登录网站,换成firefox登录状态如何
不同浏览器使用不同的Cookie管理机制,无法共用Cookie

### 4.9 本章小结

## 第5章 PHP与数据库基础

### 5.1 什么是PDO

PDO（PHP Data Objects）提供一个通用接口访问多种数据库，即抽象的数据模型支持连接多种数据库

PDO扩展为PHP定义了一个访问数据库的轻量、持久的接口。

#### 5.1.1 PDO预定义类

PDO包含三个预定义类：`PDO`, `PDOStatement`和`PDOExcepton`

1. PDO类
PDO类代表一个PHP和数据库之间的连接

2. PDOStatement类
PDOStatement类代表一条预处理语句以及语句执行后的联合结果集

3. PDOException类
PDOException类是对exception的简单重写

#### 5.1.2 如何使用PDO

#### 5.1.3 PDO参数绑定与预编译


`bindParam`, `addslashes`

使用PDO从MYSQL数据库查询的数据都是string

#### 5.1.4 PDO事务处理

#### 5.1.5 PDO的效率问题

### 5.2 数据库应用优化

数据库的优化主要包括两个方面，一方面是sql程序语句的优化，另一方面是
数据库服务器和配置的优化

##### 5.2.1 基本语句优化的10个原则

1. 尽量避免在列上进行运算，这样会导致索引失效
2. 使用JOIN时，应该用小结果集驱动大结果集
3. 注意like模糊查询的使用，避免是用%%
4. 仅列出需要查询的字段，这对速度不会有明显影响，主要考虑节省内存
5. 使用批量插入语句节省交互
6. limit的基数比较大时使用between
7. 不要使用rand函数获取多条随机记录
8. 避免使用NULL
9. 不要使用count(id)
10 不要做无谓的排序操作，而应尽可能在索引中完成排序

##### 5.2.2 索引与性能分析

`explain`

id：查询的序列号
select_type：查询的类型，主要包括普通查询、联合查询和子查询
table：所访问的数据库中的表的名称
type：联合查询使用的类型
possible_keys：指出mysql能使用哪个索引在该表中找到该行
key：显示mysql实际决定使用的键
key_len：显示mysql决定使用的键长度
ref：显示哪个字段或常数与key一起被使用
rows：表示mysql要遍历多少数据才能找到所需的结果集
extra：如果是only index，意味着信息只能用索引树中的信息检索，这比扫描整个表要快，
如果是where used，则表示使用了where限制，但是用索引还不够，如果是impossible where，
则表示通过收集到的统计信息判断出不可能存在的结果，如果是using filesort，表示包含orderby
且无法使用索引进行排序操作，如果是using temporary，使用临时表，如果是 select tables optimized way，使用
聚合函数，

type显示的访问类型是较为重要的指标
system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all

##### 5.2.3 服务器和配置的优化

MyISAM注重性能，InnoDB注重事务

选择最合适的存储引擎是优化的第一步
1. 存储引擎的选择方法
了解读写比，理想的读写比为100:1，如果读写比达到10:1时，以写为主
（1）采用MyISAM引擎
R/W》100:1且update相对较少
并发不高，不需要事务
硬件资源有限
（2）采用InnoDB引擎
R/W比较小，频繁更新大字段
表数据量超过1000万，并发高
安全性和可用性要求高
（3）采用Memory引擎
有足够的内存
对数据一致性要求不高
需要定期归档的数据

2. mysql服务器调整优化措施
1）关闭不必要的二进制日志和慢查询日志，仅在内存足够或开发调试时打开
2）适度使用query cache
3）增加mysql运行的最大连接数
4）对于myisam表适当增加key_buffer_size
5）从表中删除大量行后，可运行optimize table tablename进行碎片整理

##### 5.2.4 MySQL瓶颈及应对措施

1）增加MySQL配置中buffer和Cache的数值，增加服务器CPU数量和内存的大小，
这样能很大程度上应对MySQL的性能瓶颈
2）使用第三方引擎或衍生版本
3）迁移到其中数据库
4）对数据库进行分区、分表操作，减少单表体积
5）使用NoSQL等服务解决方案
6）使用中间件做数据拆分和分布式部署
7）使用数据库连接池技术

#### 5.3 数据库设计

##### 5.3.1 范式与反范式

1）核心业务使用范式
2）弱一致性需求-反ACID
3）空间换时间，冗余换效率
4）避免不必要的冗余

##### 5.3.2 数据库分区

所谓分区，就是把一个数据表的文件和索引分散存储在不同的物理文件中

```mysql
SHOW VARIABLES LIKE '%partition%';

CREATE TABLE foo (
  id INT NOT NULL AUTO_INCREMENT,
  created DATETIME,
  PRIMARY KEY (id, created)
) ENGINE = INNODB PARTITION BY RANGE (TO_DAYS(created)) (
  PARTITION foo_1 VALUES LESS THAN (TO_DAYS('2009-01-01')),
  PARTITION foo_2 VALUES LESS THAN (TO_DAYS('2010-01-01'))
);

ALTER TABLE foo ADD PARTITION (
  PARTITION foo3 VALUES LESS THAN (TO_DAYS('2011-01-01'))
);
```

分区的限制：

1. 主键或者唯一索引必须包含分区字段
2. 只能通过int类型的字段或者返回int类型的表达式分区，或者使用YEAR或
TO_DAYS等函数
3. 单个表最多1024个分区
4. 采用分区的表不支持外键
5. 分区后，可能会造成索引失效

##### 5.3.3 分表的应用

对于较庞大的数据，不论是否进行分表，都必须考虑功能和效率的平衡性，并
在功能上做出让步，我们不能事事迁就用户，而应该对某些影响效率的功能做
出限制。

#### 5.4 MySQL的高级应用

##### 5.4.1 MySQL自增长序列

序列的试用场景：
1. 业务复杂，需要定制和控制主键
2. 希望手工维护自增长，方便数据迁移
3. 当事务跨多表，期望事务可靠性
4. 需要一个业务上有意义的主键
5. 主键很明确地需要和其他表关联
6. 期望主键是唯一的，不需要重复利用

```mysql
DROP TABLE IF EXISTS 'sequence';
CREATE TABLE IF NOT EXISTS 'sequence' (
  'name' VARCHAR(50) NOT NULL ,
  'current_value' INT(11) NOT NULL ,
  'increment' INT(11) NOT NULL DEFAULT '1'
) ENGINE = MyISAM DEFAULT CHARSET = utf8 CHECKSUM =1 DELAY_KEY_WRITE  = 1
ROW_FORMAT = DYNAMIC COMMENT '序列表，命名s_[table_name]';
INSERT INTO 'sequence' ('name', 'current_value', 'increment') VALUES ('s_blog_account', 0, 1);

# 取当前值
DROP FUNCTION IF EXISTS 'currval';
DELIMITER //
CREATE FUNCTION 'currval' (seq_name VARCHAR(50)) RETURNS int(11)
READS SQL DATA 
DETERMINISTIC BEGIN 
DECLARE VALUE INTEGER;
SET VALUE = 0;
SELECT current_value INTO FROM sequence WHERE NAME=seq_name;
RETURN VALUE;
END //
DELIMITER ;

# 取下一个值
DROP FUNCTION IF EXISTS 'nextval';
DELIMITER //
CREATE FUNCTION 'nextval' (seq_name VARCHAR(50)) RETURNS INT(11)
DETERMINISTIC BEGIN 
UPDATE sequence SET current_value=current_value+sequence.increment WHERE NAME=seq_name;
RETURN currval(seq_name);
END //
DELIMITER ;
```
##### 5.4.2 MySQL视图

##### 5.4.3 MySQL存储过程和事件调度

```mysql
DELIMITER //
CREATE PROCEDURE 'utable' (IN $tname VARCHAR(20), IN $field VARCHAR(10))
BEGIN 
SET @sqlcmd = CONCAT("delete from ", $tname, " where ", $field, "-1");
PREPARE stmt FROM @sqlcmd;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
END //

CREATE EVENT IF NOT EXISTS event_log ON SCHEDULE EVERY 100 SECOND 
ON COMPLETION PRESERVE 
DO CALL 'utable'('log', 'isread');
```

##### 5.4.4 用MySQL模拟消息队列

##### 5.4.5 SQL注入漏洞与防范

防范
1. 如果是整型变量或字段使用intval转为数值
2. 对于字符串，用addslashes
3. 转义或过滤一些特殊字符
4. 保护表结构等关键信息
5. 任何情况下做好数据备份

#### 5.5 本章小结

###### 2018.01.26