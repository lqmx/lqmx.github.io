# 2 面向对象的设计原则

###### 20180210

## 2.1 面向对象设计的五大原则

### 2.1.1 单一职责原则(Single Pesponsibility Principle)

> 就一个类而言,应该只有一个引起它变化的原因

单一职责有两个含义:
1. 避免相同的职责分散到不同的类中
2. 避免一个类承担太多职责

为什么要遵守SRP
1. 可以减少类之间的耦合
2. 提高类的复用性

SRP的应用:

1. 工厂模式

```php
// srp-factory
interface Db_Adapter {
	public function connect($config);
	public function query($query, $handle);
}
class Db_Adapter_Mysql implements Db_Adapter {

	private $_dbLink;
	public function connect($config) {
		// ..
	}

	public function query($query, $handle) {
		// ..
	}
}
class Db_Adapter_SQLite implements Db_Adapter {

	private $_dbLink;

	public function connect($config) {
		// ..
	}

	public function query($query, $handle) {
		// ..
	}
}
class sqlFactory {
	public static function factory($type) {
		$cls_name = 'Db_Adapter_'.$type;
		return new $cls_name;
	}

}
$db = sqlFactory::factory('Mysql');
$db = sqlFactory::factory('SQLite');
```

2. 命令模式

```php
class Cook {
	public function meal () {
		echo 'meal', PHP_EOL;
	}

	public function drink() {
		echo 'drink', PHP_EOL;
	}

	public function ok () {
		echo 'ok', PHP_EOL;
	}
}
interface Command {
	public function execute(); 
}
class MealCommand implements Command {
	private $cook;
	public function __construct(Cook $cook) {
		$this->cook = $cook;
	}

	public function execute() {
		$this->cook->meal();
	}
}
class DrinkCommand implements Command {
	private $cook;
	public function __construct(Cook $cook) {
		$this->cook = $cook;
	}
	public function execute() {
		$this->cook->drink();
	}
}
class CookControl {
	private $mealcommand;
	private $drinkcommand;
	public function addCommand(Command $mealcommand, Command $drinkcommand) {
		$this->mealcommand = $mealcommand;
		$this->drinkcommand = $drinkcommand;
	}
	public function callmeal() {
		$this->mealcommand->execute();
	}
	public function calldrink() {
		$this->drinkcommand->execute();
	}
}
$control = new CookControl;
$cook = new Cook;
$mealcommand = new MealCommand($cook);
$drinkcommand = new DrinkCommand($cook);
$control->addCommand($mealcommand, $drinkcommand);
$control->callmeal();
$control->calldrink();
```

3. 代理模式

### 2.1.2 接口隔离原则(Interface Segregation Principle)

> 客户端不应该被强迫实现一些他们不会使用的接口,应该把胖接口中的方法分组,然后用多个
> 接口代替它,每个接口服务于一个子模块

ISP的观点如下:
1. 一个类对另外一个类的依赖性应当是建立在最小的接口上的
2. 客户端程序不应该依赖它不需要的接口方法(功能)

对于接口的污染,可以考虑下面两条处理方式:
1. 利用委托分离接口
2. 利用多继承分离接口

### 2.1.3 开发-封闭原则(Open Close Principle)

> 模块的行为必须是开放的、支持扩展的、而不是僵化的
> 在对模块的功能进行扩展时,不应该影响或大规模影响已有的程序模块
> 一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的

```php
interface process {
	public function process();
}
class playerencode implements process {
	public function process() {
		echo 'encode', PHP_EOL;
	}
}
class playeroutput implements process {
	public function process () {
		echo 'output', PHP_EOL;
	}
}
class playProcess {
	private $message = null;
	public function __construct() {
	}

	public function callback(event $event) {
		$this->message = $event->click();
		if($this->message instanceof process) {
			$this->message->process();
		}
	}
}
class mp4 {
	public function work() {
		$playProcess = new playProcess;
		$playProcess->callback(new event('encode'));
		$playProcess->callback(new event('output'));
	}

}
class event {
	private $m;
	public function __construct($me) {
		$this->m = $me;
	}
	public function click() {
		switch($this->m) {
		case 'encode':
			return new playerencode;
		case 'output':
			return new playeroutput;
		}
	}
}
$mp4 = new mp4();
$mp4->work();
```

如何遵守开放-封闭原则
让类依赖于固定的抽象,这个的修改是封闭的
通过面向对象的继承和多态,可以实现对抽象体的继承,通过复写其方法来
改变固有行为,实现新的扩展方法,所以对扩展是开放的

1. 在设计方面充分利用"抽象"和"封装"的思想
2. 在系统功能编程实现方面应用面向接口的编程

应用:
装饰模式

### 2.1.4 替换原则(Liskov Substitution Principle)

> 子类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方

LSP主要是针对继承的设计原则

LSP要解决的问题
1. 如何正确地进行继承方面的设计
2. 最佳的继承层次如何获得
3. 怎样避免所设计的类层次陷入不符合OCP原则的状况

如何遵守:
1. 父类的方法都要在子类中实现或者重写,并且派生类只实现其抽象类中声明的方法,
而不应该给出多余的方法定义或实现
2. 在客户端程序中只应该使用父类对象而不应该直接使用子类对象,这样可以实现
运行期绑定(多态)


```php
abstract class Cache {
	public abstract function set($key, $value, $expire = 60);
	public abstract function get($key);
	public abstract function del($key);
	public abstract function delAll();
	public abstract function has($key);
}
```

### 2.1.5 依赖倒置原则(Dependence Inversion Principle)

> 上层模块不应该依赖下层模块,它们共同依赖一个抽象

```php
interface employee {
	public function working();
}

class teacher implements employee {
	public function working() {
		echo 'teaching', PHP_EOL;
	}
}
class coder implements employee {
	public function working() {
		echo 'codeing', PHP_EOL;
	}
}
class workA {
	public function work() {
		$teacher = new teacher;
		$teacher->working();
	}
}
class workB {
	private $e;
	public function set(employee $e) {
		$this->e = $e;
	}

	public function work(){
		$this->e->working();
	}
}
$worka = new workA;
$worka->work();
$workb = new workB;
$workb->set(new teacher());
$workb->work();
```

如何满足DIP:
1. 每个较高层次类都为它所需要的服务提出一个接口声明,较低层次类实现这个接口
2. 每个高层类都通过该抽象接口使用服务

## 2.2 一个面向对象留言本的实例

用户填写信息->留言->展示

```php
// message.php
class message {
	public $name;
	public $email;
	public $content;
	public function set($name, $value) {
		$this->$name = $value;
	}

	public function get($name) {
		if(!isset($this->$name)) {
			$this->$name = NULL;
		}
		return $this->$name;
	}
}
// gbookModel.php
class gbookModel {
	private $bookPath;
	private $data;

	public function setBookPath($bookPath) {
		$this->bookPath = $bookPath;
	}

	public function open() {
	}

	public function close() {
	}

	public function read() {
		return file_get_contents($this->bookPath);
	}

	public function write($data) {
		$this->data = self::safe($data)->name."&".self::safe($data)->email."\r\nsaid: \r\n".self::safe($data)->content;
		return file_put_contents($this->bookPath, $this->data, FILE_APPEND);
	}

	public static function safe($data) {
		$reflect = new RelectionObject($data);
		$props = $reflect->getProperties();
		$messagebox = new stdClass();
		foreach($props as $prop) {
			$ivar = $prop->getName();
			$messagebox->$ivar = trim($prop->getValue($data));
		}
		return $messagebox;
	}

	public function delete() {
		file_put_contents($this->bookPath, "it's empty now");
	}

	public function readByPage() {
		$handle = file($this->bookPath);
		$count = count($handle);
		$page = isset($_GET['page'])?intval($_GET['page']):1;
		if($page < 1 || $page > $count) $page = 1;
		$pnum = 9;
		$begin = ($page-1)*$pnum;
		$end = ($begin + $pnum) > $count ? $count : $begin + $pnum;
		for($i = $begin; $i < $end; $i ++ ) {
			echo '<strong>', $i + 1, '</strong>', $handle[$i], '<br/>';
		}
		for($i = 1; $i < ceil($count/$pnum); $i++) {
			echo "<a href=? page=${i} >${i}</a>";
		}
	}

}
// leaveModel.php
class leaveModel {
	public function write(gbookModel $gb, $data) {
		$book = $gb->getBookPath();
		$gb->write($data);
	}

}
// authorControl.php
class authorControl {
	public function message(leaveModel $l, gbookModel $g, message $data) {
		$l->write($g, $data);
	}

	public function view(gbookModel $g) {
		return $g->read();
	}

	public function delete(gbookModel $g) {
		$g->delete();
		echo self::view($g);
	}

	public function viewByPage(gbookModel $g) {
		return $g->readByPage();
	}
}

$message = new message;
$message->name = 'phper';
$message->email = 'phper@php.net';
$message->content = 'a crezy phper love php so much.';
$gb = new authorControl;
$pen = new leaveModel;
$book = new gbookModel;
$book->setBookPath("./message.txt");
$gb->message($pen, $book, $message);
echo $gb->view($book);
$gb->delete($book);
```

## 2.3 面向对象的思考

对于流程明确、需求清晰、需求变更风险小的业务逻辑,过程化开发最合适,反之,抽象思维是最
合适的,用面向对象的思维去抽象业务模型并随需求不断精化,最终交付使用,其扩展度和可维护性
都要比过程化方法更好。

## 2.4 本章小结

面向对象的五大原则

###### 20180211